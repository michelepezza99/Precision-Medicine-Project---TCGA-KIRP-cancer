---
title: "DEPM Project"
subtitle: "by Domenico Azzarito, Federico Lattanzio and Michele Pezza"
output: html_notebook
---

**Project Steps:**

1.  Selection of the disease: Kidney renal papillary cell carcinoma (KIRP)
2.  Differentially expressed genes (DEGs)
3.  CoExpression Networks
4.  Differential CoExpression Network
5.  Patient Similarity Network

```{r, results='hide'}
# TCGA-KIRP:
rm(list = ls())      # clear workspace
gc()                 # garbage collection
```

The first step is to loading the required packages for the analysis:

```{r message=FALSE}
library(BiocGenerics) # Contains Bioconductor generics used internally by SummarizedExperiment and DESeq2
library(DESeq2) # Store RNA-Seq counts and normalize counts
library(psych) # correlation analysis + p-value adjustment
library(NetworkToolbox) # Additional functions for network analysis
library(ggplot2) # volcano plot, degree distribution plot and any additional plot
# library(ggnet)    
library(GGally) # Package containing ggnet2(), essential function for plotting
library(sna) # functions for clustering coefficient, components..
library(network) # defines the network() object type
library(TCGAbiolinks) # queries the GDC portal and downloads TCGA data
library(GenomicRanges)  # Gene annotation is stored as GRanges
library(SummarizedExperiment)  # TCGA RNA-Seq is stored in a SummarizedExperiment object
library(DT)  # Interactive visualization
library(igraph)
library(maftools)
library(SNFtool)
library(reshape2)
library(poweRlaw)
# sessionInfo()
```

## 1. Download data

We proceed to download the required tumor RNA-Seq data (Primary Tumor)

```{r message=FALSE, results='hide'}
proj <- "TCGA-KIRP"
dir.create(file.path(proj))
```

RNA-Seq data: primary tumor samples

```{r message=FALSE}
rna.query.C <- TCGAbiolinks::GDCquery(
  project = proj,
  data.category = "Transcriptome Profiling",
  data.type = "Gene Expression Quantification",
  workflow.type = "STAR - Counts",
  sample.type = "Primary Tumor"
)
```

Download the data from GDC to local cache folder "GDCdata" a

```{r message=FALSE}
GDCdownload(query = rna.query.C, directory = "GDCdata", method = "api")
```

Convert the downloaded files into a SummarizedExperiment object

```{r message=FALSE, results='hide'}
rna.data.C <- GDCprepare(rna.query.C, directory = "GDCdata")
```

Extract the raw count matrix (genes x tumor samples)

```{r message=FALSE}
rna.expr.data.C <- assay(rna.data.C)
```

Extract gene annotation (Ensembl IDs, gene symbols, chromosomes, etc.)

```{r message=FALSE}
genes.info <- BiocGenerics::as.data.frame(rowRanges(rna.data.C))
```

Checks:

```{r message=FALSE}
head(rna.query.C$results[[1]]$cases)
rna.data.C
dim(rna.expr.data.C)
head(genes.info)

```

Download normal samples

```{r message=FALSE}
# RNA-Seq data: solid tissue normal samples
rna.query.N <- TCGAbiolinks::GDCquery(
  project = proj,
  data.category = "Transcriptome Profiling",
  data.type = "Gene Expression Quantification",
  workflow.type = "STAR - Counts",
  sample.type = "Solid Tissue Normal"
)
```

Download normal data

```{r message=FALSE}
GDCdownload(query = rna.query.N, directory = "GDCdata", method = "api")
```

Prepare SummarizedExperiment for normal samples

```{r message=FALSE, results='hide'}
rna.data.N <- GDCprepare(rna.query.N, directory = "GDCdata")
```

Extract raw counts for normal samples

```{r message=FALSE}
rna.expr.data.N <- assay(rna.data.N)
```

Extract gene annotation for normal dataset

```{r}
genes.info2 <- BiocGenerics::as.data.frame(rowRanges(rna.data.N))
```

Sanity check: tumor and normal gene annotations should match

```{r}
all(na.omit(genes.info2) == na.omit(genes.info))
```

Checks:

```{r}
dim(rna.expr.data.N)
rna.data.N
```

Results:

-   Tumor: 60,660 genes × 290 samples

-   Normal: 60,660 genes × 32 samples

-   Gene annotation: identical between tumor and normal

### Data cleaning

#### Inspect basic structure

Dimensions: genes x samples

```{r}
dim(rna.expr.data.C)  # tumor
dim(rna.expr.data.N)  # normal
```

Quick look at column names (TCGA barcodes)

```{r}
head(colnames(rna.expr.data.C))
head(colnames(rna.expr.data.N))
```

Extract patient IDs (first 12 characters of barcode)

```{r}
patients.C <- substr(colnames(rna.expr.data.C), 1, 12)
patients.N <- substr(colnames(rna.expr.data.N), 1, 12)
```

How many unique patients in each group?

```{r}
length(unique(patients.C))
length(unique(patients.N))
```

Distribution of tumor samples per patient (to detect duplicates)

```{r,results='hide'}
sort(table(patients.C))
```

#### Keep only patients with exactly ONE tumor sample

Table: how many tumor samples per patient

```{r}
tab.C <- table(patients.C)
```

Select patient IDs with exactly 1 primary tumor sample

```{r}
single.C <- names(tab.C[tab.C == 1])
```

Indices of columns in tumor matrix corresponding to single-sample patients

```{r}
idx.single.C <- which(patients.C %in% single.C)
```

Tumor expression matrix: only one tumor sample per patient

```{r}
expr.C <- as.data.frame(rna.expr.data.C[, idx.single.C])
```

Normal expression matrix: start with all normals

```{r}
expr.N <- as.data.frame(rna.expr.data.N)
```

#### Rename columns to pure patient IDs

Use only the 12-character patient ID as column names

```{r}
colnames(expr.C) <- substr(colnames(expr.C), 1, 12) 
colnames(expr.N) <- substr(colnames(expr.N), 1, 12)
```

quick check

```{r}
head(colnames(expr.C))
head(colnames(expr.N))
```

Make sure there are no duplicated column names now

```{r}
sum(duplicated(colnames(expr.C)))
sum(duplicated(colnames(expr.N)))
```

#### Keep only patients with BOTH tumor and normal samples

Patient IDs present in BOTH expr.C (tumor) and expr.N (normal)

```{r}
common_ids <- intersect(colnames(expr.C), colnames(expr.N))
length(common_ids) # this is the number of paired patients
```

Subset both matrices to the same set of patients

```{r}
expr.C <- expr.C[, common_ids, drop = FALSE] 
expr.N <- expr.N[, common_ids, drop = FALSE]
```
#### Remove genes with zero counts in ANY sample
We remove genes that have zero counts in at least one sample (tumor or normal) since they do not provide useful information for differential expression analysis and we aim to avoid mathematical issues during log fold change calculations.
```{r}
nonzero_genes <- rowSums(expr.C == 0) == 0 & rowSums(expr.N == 0) == 0

expr.C <- expr.C[nonzero_genes, ]
expr.N <- expr.N[nonzero_genes, ]

cat("Genes kept:", sum(nonzero_genes), "\n")

```

Sanity checks

```{r}
ncol(expr.C) # number of paired tumor samples 
ncol(expr.N) # number of paired normal samples 
all(colnames(expr.C) == colnames(expr.N)) # should be TRUE
```

#### Final technical checks on counts

Check that genes (rows) are aligned between tumor and normal

```{r}
all(rownames(expr.C) == rownames(expr.N)) # must be TRUE
```

Check data types and missingness

```{r}
typeof(expr.C[1, 1])            # should be "integer" or "double" 
any(is.na(expr.C))              # should be FALSE 
any(is.nan(as.matrix(expr.C)))  # should be FALSE

typeof(expr.N[1, 1]) 
any(is.na(expr.N)) 
any(is.nan(as.matrix(expr.N)))
```

At this point:

-   expr.C = raw tumor counts, genes x N_paired patients

-   expr.N = raw normal counts, genes x N_paired patients

-   Columns in expr.C and expr.N are the SAME patients, SAME order

These are the matrices we will feed into DESeq2 for normalization.

### Normalizing data with DESeq2

Check alignment of tumor and normal matrices

```{r}
all(rownames(expr.C) == rownames(expr.N)) # Must be TRUE (same gene order)
```

Combine into full dataset: normals first, then tumors

```{r}
full.data <- cbind(expr.N, expr.C) 
full.data <- data.frame(full.data)

dim(full.data) # should be 60660 x 64 (32 normal + 32 tumor)
```

### Build metadata

```{r}
metad <- data.frame( 
    condition = factor(c( 
        rep("normal", ncol(expr.N)), 
        rep("cancer", ncol(expr.C)) 
    )) 
)
```

Row names must match full.data column names

```{r}
rownames(metad) <- colnames(full.data)
```

DESeq2 expects gene_id as a column when tidy=TRUE

```{r}
full.data <- cbind(gene_id = rownames(full.data), full.data)
```

### Build DESeq2 dataset

```{r}
dds <- DESeqDataSetFromMatrix( 
    countData = full.data, 
    colData = metad, 
    design = ~ condition, 
    tidy = TRUE 
)
```

Sanity check

```{r}
dim(counts(dds)) # should be 60660 x 64
```

### Filter low-expression genes

At least 10 counts in 90% of **all** samples (32 normal + 32 cancer = 64 → 90% = 57)

```{r}
total_samples <- ncol(expr.N) + ncol(expr.C)  # 64
threshold <- floor(0.9 * total_samples)       # 57

cat("Total samples:", total_samples, "\n")
cat("Filtering threshold (90%):", threshold, "samples\n")

keep <- rowSums(counts(dds) >= 10) >= threshold
dds <- dds[keep, ]

cat("Genes before filtering:", nrow(full.data), "\n")
cat("Genes after filtering:", nrow(dds), "\n")
cat("Genes removed:", nrow(full.data) - sum(keep), "\n")
```

### Normalize using DESeq2 size factors

```{r}
dds <- estimateSizeFactors(dds)

normalized_counts <- counts(dds, normalized = TRUE)

# No gene should be zero in all samples
sum(rowSums(normalized_counts == 0) == ncol(normalized_counts))
```

### Split normalized matrix back into normal/tumor

```{r}
filtr.expr.n <- as.data.frame( 
    normalized_counts[, 1:ncol(expr.N)] 
)

filtr.expr.c <- as.data.frame( 
    normalized_counts[, (ncol(expr.N) + 1):ncol(normalized_counts)] 
)
```

Keep original patient IDs (DESeq2 sometimes adds .1, .2)

```{r}
colnames(filtr.expr.n) <- colnames(expr.N) 
colnames(filtr.expr.c) <- colnames(expr.C)
```

### Final checks

```{r,results='hide'}
# Same genes
all(rownames(filtr.expr.c) == rownames(filtr.expr.n))

# Same patients
all(colnames(filtr.expr.c) == colnames(filtr.expr.n))

nrow(filtr.expr.c)   # number of filtered/normalized genes
ncol(filtr.expr.c)   # should be 32

sizeFactors(dds)

```
```{r}
summary(sizeFactors(dds))
```

**Output:**

-   **filtr.expr.n = normalized expression for 32 normal samples**

-   **filtr.expr.c = normalized expression for 32 tumor samples**

These matrices are what we will use for:

-   DEGs

-   Volcano Plot

-   Co-expression networks

-   Differential networks

-   PSN and SNF

## 2. Differential Expression Analysis (DEGs)

### Compute log2 Fold Change

```{r}
log2fc <- log2(rowMeans(filtr.expr.c) / rowMeans(filtr.expr.n))
names(log2fc) <- rownames(filtr.expr.c)
```

### Compute paired t-test p-values

```{r}
pval <- sapply(
  1:nrow(filtr.expr.c),
  function(i) t.test(
    as.numeric(filtr.expr.c[i, ]),
    as.numeric(filtr.expr.n[i, ]),
    paired = TRUE
  )$p.value
)
```

### FDR correction

```{r}
pval_fdr <- p.adjust(pval, method = "fdr")
```

### Build DEG table

```{r}
deg.table <- data.frame(
  gene        = rownames(filtr.expr.c),
  log2FC      = log2fc,
  pvalue      = pval,
  pvalue_fdr  = pval_fdr,
  row.names   = rownames(filtr.expr.c)
)
```

### Apply thresholds

```{r}
FDR_threshold <- 0.05
FC_threshold  <- 2

deg.genes <- subset(
  deg.table,
  abs(log2FC) >= FC_threshold & pvalue_fdr <= FDR_threshold
)

cat("Number of DEGs:", nrow(deg.genes), "\n")
```

### Volcano plot

```{r}
deg.table$color <- "NO"
deg.table$color[deg.table$log2FC >= FC_threshold & deg.table$pvalue_fdr <= FDR_threshold] <- "UP"
deg.table$color[deg.table$log2FC <= -FC_threshold & deg.table$pvalue_fdr <= FDR_threshold] <- "DOWN"
deg.table$color <- factor(deg.table$color, levels = c("DOWN", "NO", "UP"))

ggplot(deg.table, aes(x = log2FC, y = -log10(pvalue_fdr), color = color)) +
  geom_point(alpha = 0.6) +
  xlab("log2 Fold Change") +
  ylab("-log10 FDR") +
  geom_vline(xintercept = c(-FC_threshold, FC_threshold), col = "red") +
  geom_hline(yintercept = -log10(FDR_threshold), col = "red") +
  theme_minimal()


DEG_list <- rownames(deg.genes)
length(DEG_list)
```

## 3. CoExpression Networks (Binary with Statistical Testing)

### Extract the DEG expression matrices

Keep only DEGs in the normalized matrices

```{r}
expr_deg_cancer <- filtr.expr.c[DEG_list, ]
expr_deg_normal <- filtr.expr.n[DEG_list, ]
```

Log transform

```{r}
expr_deg_cancer <- log2(expr_deg_cancer + 1)
expr_deg_normal <- log2(expr_deg_normal + 1)
```

Check dimensions

```{r}
dim(expr_deg_cancer)
dim(expr_deg_normal)
all(rownames(expr_deg_cancer) == rownames(expr_deg_normal))
```

### Compute correlations with statistical testing

```{r}
# Cancer correlation with FDR-adjusted p-values
cor.mat.c <- corr.test(
  t(expr_deg_cancer), 
  use = "pairwise",
  method = "pearson",
  adjust = "fdr",
  ci = FALSE
)

rho.c <- cor.mat.c$r
diag(rho.c) <- 0
qval.c <- cor.mat.c$p
qval.c[lower.tri(qval.c)] <- t(qval.c)[lower.tri(qval.c)]

# Normal correlation with FDR-adjusted p-values
cor.mat.n <- corr.test(
  t(expr_deg_normal), 
  use = "pairwise",
  method = "pearson",
  adjust = "fdr",
  ci = FALSE
)

rho.n <- cor.mat.n$r
diag(rho.n) <- 0
qval.n <- cor.mat.n$p
qval.n[lower.tri(qval.n)] <- t(qval.n)[lower.tri(qval.n)]
```

### Build BINARY adjacency matrices

Both statistical significance (FDR) and correlation magnitude are enforced.

```{r}
corr_threshold_c <- 0.6  # Cancer correlation threshold
corr_threshold_n <- 0.8 # Normal correlation threshold (more stringent)
pval_threshold   <- 0.05 # FDR-adjusted p-value threshold

adj_mat_c <- ((abs(rho.c) >= corr_threshold_c) & (qval.c <= pval_threshold)) * 1
adj_mat_n <- ((abs(rho.n) >= corr_threshold_n) & (qval.n <= pval_threshold)) * 1
```

### Network density check

```{r}
cat("=== Cancer Network Statistics ===\n")
cat("Total possible edges:", nrow(adj_mat_c) * (nrow(adj_mat_c) - 1) / 2, "\n")
cat("Significant edges:", sum(adj_mat_c != 0) / 2, "\n")
cat("Network density:", round(sum(adj_mat_c != 0) / (nrow(adj_mat_c) * (nrow(adj_mat_c) - 1)), 4), "\n")
cat("  - Positive correlations:", sum((adj_mat_c == 1) & (rho.c > 0)) / 2, "\n")
cat("  - Negative correlations:", sum((adj_mat_c == 1) & (rho.c < 0)) / 2, "\n\n")

cat("=== Normal Network Statistics ===\n")
cat("Total possible edges:", nrow(adj_mat_n) * (nrow(adj_mat_n) - 1) / 2, "\n")
cat("Significant edges:", sum(adj_mat_n != 0) / 2, "\n")
cat("Network density:", round(sum(adj_mat_n != 0) / (nrow(adj_mat_n) * (nrow(adj_mat_n) - 1)), 4), "\n")
cat("  - Positive correlations:", sum((adj_mat_n == 1) & (rho.n > 0)) / 2, "\n")
cat("  - Negative correlations:", sum((adj_mat_n == 1) & (rho.n < 0)) / 2, "\n")
```

### Compute degree for each network

```{r}
degree_c <- colSums(adj_mat_c != 0)
names(degree_c) <- rownames(adj_mat_c)
degree_c <- sort(degree_c, decreasing = TRUE)

degree_n <- colSums(adj_mat_n != 0)
names(degree_n) <- rownames(adj_mat_n)
degree_n <- sort(degree_n, decreasing = TRUE)
```

### Check if scale-free network (plot degree distribution)

Cancer Network degree distribution

```{r}
hist(degree_c, breaks = 50, main = "Cancer Network Degree Distribution",
     xlab = "Degree", col = "lightblue", freq = FALSE)
```

To check scale-free: plot log-log (degree vs frequency)

```{r}
deg_freq_c <- table(degree_c[degree_c > 0])
if (length(deg_freq_c) > 1) {
  plot(log10(as.numeric(names(deg_freq_c))), log10(as.numeric(deg_freq_c)), 
       main = "Cancer: Log-Log Degree Distribution", xlab = "Degree", ylab = "Frequency", 
       pch = 16, col = "lightblue", cex = 1.0)
  fit_c <- lm(log10(as.numeric(deg_freq_c)) ~ log10(as.numeric(names(deg_freq_c))))
  abline(fit_c, col = "lightcoral", lwd = 2, lty = 2)
  legend("topright", legend = paste("R² =", round(summary(fit_c)$r.squared, 3)),
         bty = "n")
}
```

Normal Network degree distribution

```{r}
hist(degree_n, breaks = 50, main = "Normal Network Degree Distribution",
     xlab = "Degree", col = "lightgreen", freq = FALSE)
```

To check scale-free: plot log-log (degree vs frequency)

```{r}
deg_freq_n <- table(degree_n[degree_n > 0])
if (length(deg_freq_n) > 1) {
  plot(log10(as.numeric(names(deg_freq_n))), log10(as.numeric(deg_freq_n)), 
       main = "Normal: Log-Log Degree Distribution", xlab = "Degree", ylab = "Frequency", 
       pch = 16, col = "lightgreen", cex = 1.0)
  fit_n <- lm(log10(as.numeric(deg_freq_n)) ~ log10(as.numeric(names(deg_freq_n))))
  abline(fit_n, col = "lightcoral", lwd = 2, lty = 2)
  legend("topright", legend = paste("R² =", round(summary(fit_n)$r.squared, 3)),
         bty = "n")
}
```

### Find hubs (top 5% highest degree)

```{r}
y <- quantile(degree_n[degree_n>0], 0.95)
x <- quantile(degree_c[degree_c>0], 0.95)

hubs_c <- degree_c[degree_c>=x]
hubs_n <- degree_n[degree_n>=y]
```

### Compare hubs between conditions

Common hubs

```{r}
common_hubs <- intersect(names(hubs_c), names(hubs_n))
```

Hubs unique to cancer

```{r}
selective_hubs_c <- setdiff(names(hubs_c), names(hubs_n))
```

Hubs unique to normal

```{r}
selective_hubs_n <- setdiff(names(hubs_n), names(hubs_c))
```

Output

```{r}
cat("Number of cancer hubs:", length(hubs_c), "\n")
cat("Number of normal hubs:", length(hubs_n), "\n")
cat("Number of common hubs:", length(common_hubs), "\n")
cat("Number of selective hubs in cancer:", length(selective_hubs_c), "\n")
cat("Number of selective hubs in normal:", length(selective_hubs_n), "\n")
```

**Output:**

-   **adj_mat_c = adjacency matrix for cancer co-expression network**

-   **adj_mat_n = adjacency matrix for normal co-expression network**

-   **hubs_c = hubs in cancer network**

-   **hubs_n = hubs in normal network**

## 4. Differential Co-expressed Network

Set Z-score threshold

```{r}
z_threshold <- 5 # more restrictive to keep the network sparser
```

Sample sizes

```{r}
n_c <- ncol(expr_deg_cancer)  # Number of cancer samples
n_n <- ncol(expr_deg_normal)  # Number of normal samples
```

### Compute differential adjacency matrix

Function to compute Fisher's Z-transform

```{r}
fisher_z <- function(r) {
  0.5 * log((1 + r) / (1 - r))
}
```

Compute Z-transforms for cancer and normal correlations

```{r}
z_c <- fisher_z(rho.c)
z_n <- fisher_z(rho.n)
```

Compute Z-score for difference: (z_c - z_n) / sqrt(1/(n_c-3) + 1/(n_n-3))

```{r}
se <- sqrt(1/(n_c - 3) + 1/(n_n - 3))
z_diff <- (z_c - z_n) / se
```

Binary adjacency

```{r}
adj_mat_diff <- z_diff
adj_mat_diff <- adj_mat_diff_bin <- (abs(z_diff) >= z_threshold) * 1
```

Remove diagonal

```{r}
diag(adj_mat_diff) <- 0
```

### Compute degree for differential network

```{r}
degree_diff <- colSums(adj_mat_diff != 0)
names(degree_diff) <- rownames(adj_mat_diff)
degree_diff <- sort(degree_diff, decreasing = TRUE)
```

### Check if scale-free network (plot degree distribution)

Differential network degree distribution

```{r}
hist(degree_diff, breaks = 50, main = "Differential Network Degree Distribution", 
     xlab = "Degree", col = "plum", freq = FALSE)
```

Log-log plot

```{r}
deg_freq_diff <- table(degree_diff)
if (length(deg_freq_diff) > 1) {
  plot(log(as.numeric(names(deg_freq_diff))), log(deg_freq_diff), 
       main = "Differential: Log-Log Degree Distribution", xlab = "log(Degree)", ylab = "log(Frequency)", 
       pch = 16, col = "plum", cex = 0.8) 
}
```

### Find hubs (top 5% highest degree)

```{r}
z <- quantile(degree_diff[degree_diff>0], 0.95)
hubs_diff <- degree_diff[degree_diff>=z]
```

### Compare hubs with task 3 (cancer and normal hubs)

Common with cancer hubs

```{r}
common_hubs_diff_c <- intersect(names(hubs_diff), names(hubs_c))
```

Common with normal hubs

```{r}
common_hubs_diff_n <- intersect(names(hubs_diff), names(hubs_n))
```

Unique to differential

```{r}
selective_hubs_diff <- setdiff(names(hubs_diff), union(names(hubs_c), names(hubs_n)))
```

Output

```{r}
cat("Number of differential hubs:", length(hubs_diff), "\n")
cat("Number of hubs common with cancer:", length(common_hubs_diff_c), "\n")
cat("Number of hubs common with normal:", length(common_hubs_diff_n), "\n")
cat("Number of selective hubs in differential:", length(selective_hubs_diff), "\n")
```

### Subnetwork Plot of the Most Relevant Gene (Highest Degree in Differential Network)

Find the gene with the highest degree in the differential network

```{r}
top_gene <- names(degree_diff)[1]  # Highest degree
top_gene_degree <- degree_diff[1]

cat("Most relevant gene:", top_gene, "with degree:", top_gene_degree, "\n")
```

Find neighbors: genes connected to top_gene in adj_mat_diff

```{r}
neighbors <- which(adj_mat_diff[top_gene, ] != 0)
neighbor_names <- colnames(adj_mat_diff)[neighbors]
```

Subset: top_gene and its neighbors

```{r}
subnet_nodes <- unique(c(top_gene, neighbor_names))
subnet_adj <- adj_mat_diff[subnet_nodes, subnet_nodes]
```

Create network object

```{r}
net_subnet <- network(subnet_adj, matrix.type = "adjacency", ignore.eval = FALSE, names.eval = "weights", directed = FALSE)
```

Set attributes for plotting

```{r}
net_subnet %v% "type" <- ifelse(network.vertex.names(net_subnet) == top_gene, "top_gene", "neighbor")
net_subnet %v% "color" <- ifelse(net_subnet %v% "type" == "top_gene", "red", "blue")
network::set.edge.attribute(net_subnet, "edgecolor", "green") 
```

Plot subnetwork

```{r}
ggnet2(net_subnet, color = "color", alpha = 0.7, size = 3,
       edge.color = "edgecolor", edge.alpha = 1, edge.size = 0.5,
       node.label = NULL, label.color = "black", label.size = 4) +
  ggtitle(paste("Subnetwork of", top_gene, "(Highest Degree in Differential Network)")) +
  guides(size = "none")
```

**Output:**

-   **adj_mat_diff = adjacency matrix for differential co-expression network**

-   **hubs_diff = hubs in differential network**

## 5. Patient Similarity Network (PSN)

### a. Computation of the PSN

#### Data preparation

```{r}
# we use expr_deg_cancer because it contains normalized and log-transoformed data
# dds or rna.expr.data.C are raw counts so if used well expressed genes would end up dominating the calculation
target_data <- as.matrix(expr_deg_cancer)
```

Check dimension

```{r}
print(dim(target_data)) # we expect N_DEGs x 32 patients
```

#### Calculation of the similarity matrix

Calculate Pearson correlation between patients (columns)

```{r}
patient_sim_matrix <- cor(target_data, method = "pearson")
```

#### Clean-up of the matrix

Set the diagonal to 0 to remove self-loops

```{r}
diag(patient_sim_matrix) <- 0
dim(patient_sim_matrix)
```

#### Manage negative correlations

We're only interested in positive correlations

```{r}
patient_sim_matrix[patient_sim_matrix<0] <- 0
```

#### Create the network object

```{r}
psn_graph <- graph_from_adjacency_matrix(
  patient_sim_matrix,
  mode = "undirected",
  weighted = TRUE,
  diag = FALSE
)
```

#### Check of the graph

```{r}
cat("# of nodes (patients):", vcount(psn_graph), "\n")
cat("# of edges:", ecount(psn_graph), "\n")
```

Plot of the PSN

```{r}
# creates a network object because ggnet2 needs it for plotting
# otherwise by passing an igraph object such as psn_graph, it would need an additional library
net_obj <- network(patient_sim_matrix, 
                   matrix.type = "adjacency", 
                   ignore.eval = FALSE,    # keeps weights
                   names.eval = "weights", 
                   directed = FALSE)

ggnet2(net_obj,
       size = 6,
       color = "orange",
       label = TRUE,
       label.size = 3,
       label.color = "black",
       edge.size = "weights",      
       edge.color = "gray80"
) +
  ggtitle("Patient Similarity Network")
```

### b. Community detection

#### Applying the Louvain Algorithm

```{r}
louvain_cl <- cluster_louvain(psn_graph)
```

#### Create the result dataframe

```{r}
comm_res <- data.frame(
  patient = names(membership(louvain_cl)),
  community = as.character(membership(louvain_cl)),
  stringsAsFactors = FALSE
)
```

#### Network Preparation for Plotting

Filter the matrix by applying a threshold to keep only the strongest conenctions

```{r}
l_comp <- patient_sim_matrix

# Apply a threshold
threshold_plot <- 0.7 
l_comp[abs(l_comp) < threshold_plot] <- 0
diag(l_comp) <- 0
```

```{r}
net_final <- network(l_comp, 
                     matrix.type = "adjacency", 
                     ignore.eval = FALSE, 
                     names.eval = "weights", 
                     directed = FALSE)
```

#### Assigning attributes

```{r}
net_names <- network.vertex.names(net_final)
net_final %v% "community" <- comm_res$community[match(net_names, comm_res$patient)]
network::set.edge.attribute(net_final, "edgecolor", "gray90")
```

#### Check how many communities we have

```{r}
n_communities <- length(unique(net_final %v% "community"))
cat("Number of communities found:", n_communities, "\n")
```

#### Plot

```{r}
# Create colour palette (Dynamic based on number of communities)
set.seed(13)
# Sample distinct colors
pal <- sample(colors(distinct = TRUE), n_communities)
names(pal) <- sort(unique(net_final %v% "community"))

ggnet2(net_final, 
       color = "community", 
       palette = pal, 
       alpha = 0.9, 
       size = 6, 
       label = TRUE,               # patient IDs
       label.size = 3,
       edge.color = "edgecolor", 
       edge.alpha = 0.8, 
       edge.size = 0.3) +
  guides(size = "none") +
  ggtitle("PSN Community Structure (Louvain)")
```

## 5. PSN USING NORMAL GENE EXPRESSION

Data preparation

```{r}
target_data_normal <- as.matrix(expr_deg_normal)   # DEGs × Patients (normal samples)

cat("Dimensioni matrice NORMAL (DEGs x Patients):\n")
print(dim(target_data_normal))
```

Similarity matrix calculation

```{r}
psn_normal_matrix <- cor(target_data_normal, method = "pearson")

# Remove auto-correlations
diag(psn_normal_matrix) <- 0

# Consider only positive correlations
psn_normal_matrix[psn_normal_matrix < 0] <- 0
```

Create the network object

```{r}
psn_graph_normal <- graph_from_adjacency_matrix(
  psn_normal_matrix,
  mode = "undirected",
  weighted = TRUE,
  diag = FALSE
)
cat("NORMAL PSN — Nodes:", vcount(psn_graph_normal),
    "Edges:", ecount(psn_graph_normal), "\n")
```

Community detection with Louvain

```{r}

louvain_normal <- cluster_louvain(psn_graph_normal)

comm_res_normal <- data.frame(
  patient = names(membership(louvain_normal)),
  community_normal = as.character(membership(louvain_normal)),
  stringsAsFactors = FALSE
)

cat("Number of communities (NORMAL):",
    length(unique(comm_res_normal$community_normal)), "\n")
```

Preparation for plotting

```{r}

plot_threshold <- 0.7
psn_plot_mat <- psn_normal_matrix
psn_plot_mat[psn_plot_mat < plot_threshold] <- 0


net_normal <- network(psn_plot_mat,
                      matrix.type = "adjacency",
                      ignore.eval = FALSE,
                      names.eval = "weights",
                      directed = FALSE)

net_names_norm <- network.vertex.names(net_normal)
net_normal %v% "community" <- comm_res_normal$community_normal[
  match(net_names_norm, comm_res_normal$patient)
]
```

Plot Normal PSN

```{r}
set.seed(77)
n_comm_norm <- length(unique(net_normal %v% "community"))
palette_norm <- sample(colors(distinct = TRUE), n_comm_norm)
names(palette_norm) <- sort(unique(net_normal %v% "community"))

ggnet2(net_normal,
       color = "community",
       palette = palette_norm,
       size = 6,
       label = TRUE,
       label.size = 3,
       edge.color = "gray85",
       edge.alpha = 0.8) +
  ggtitle("Patient Similarity Network — NORMAL (DEGs)")
```

Comparison between Tumor and Normal PSNs

```{r}
comparison_psn <- merge(comm_res, comm_res_normal, by = "patient")
colnames(comparison_psn) <- c("Patient", "Cancer_Community", "Normal_Community")
conf_mat_norm <- table(
  Cancer = comparison_psn$Cancer_Community,
  Normal = comparison_psn$Normal_Community
)
print("Confusion Matrix (Cancer vs Normal PSN):")
print(conf_mat_norm)
```

Heatmap of the confusion matrix

```{r}
melt_norm <- as.data.frame(as.table(conf_mat_norm))
colnames(melt_norm) <- c("Cancer_Group", "Normal_Group", "Count")

ggplot(melt_norm, aes(x = Normal_Group, y = Cancer_Group, fill = Count)) +
  geom_tile(color = "white") +
  geom_text(aes(label = Count), color = "black", size = 5) +
  scale_fill_gradient(low = "white", high = "steelblue") +
  labs(title = "Comparison: PSN Cancer vs PSN Normal",
       x = "Normal communities",
       y = "Cancer communities") +
  theme_minimal() +
  theme(panel.grid.major = element_blank())
```

## 5. Patient Similarity Network (PSN)

### c. Similarity Network Fusion

#### Download & Processing of Mutation Data

We download the Simple Nucleotide Variation data for TCGA-KIRP and convert it into a binary mutation matrix.

```{r message=FALSE}
query_mut <- TCGAbiolinks::GDCquery(
  project = proj, 
  data.category = "Simple Nucleotide Variation", 
  data.type = "Masked Somatic Mutation",
  workflow.type = "Aliquot Ensemble Somatic Variant Merging and Masking" # current standard 
)
```

Actual download **run only once**

```{r message=FALSE}
GDCdownload(query = query_mut, directory = "GDCdata", method = "api")
```

Convert the downloaded files into a SummarizedExperiment object

```{r message=FALSE}
mut_data_prepared <- GDCprepare(query_mut)
```

Reading with maftools

```{r}
maf_obj <- read.maf(maf = mut_data_prepared)
```

Create the bianry matrix (Patients x Genes)

```{r}
mut_count_matrix <- mutCountMatrix(maf_obj) # matrix with the count of the mutations
```

Transpose the matrix in order to have patients on the rows and genes on the columns

```{r}
mut_matrix_binary <- t(mut_count_matrix)
```

Convert in binary (1 if mutated, 0 otherwise)

```{r}
mut_matrix_binary[mut_matrix_binary > 0] <- 1
```

Use only the 12-character patient ID as row names

```{r}
rownames(mut_matrix_binary) <- substr(rownames(mut_matrix_binary), 1, 12)
```

Remove possible duplicates

```{r}
mut_matrix_binary <- mut_matrix_binary[!duplicated(rownames(mut_matrix_binary)), ]
```

#### Patient Alignment (Expression vs Mutation)

We need to ensure both matrices analyze exactly the same set of patients.

```{r}
patients_rna <- substr(colnames(target_data), 1, 12) # patients used in the 5a section (expression)
patients_mut <- rownames(mut_matrix_binary) # patients available in mutations
```

Find the intersection (common patients)

```{r}
common_patients <- intersect(patients_rna, patients_mut)
```

Quick check

```{r}
cat("Esempio RNA:", head(patients_rna, 3), "\n")
cat("Esempio MUT:", head(patients_mut, 3), "\n\n")

cat("Patients with RNA data:", length(patients_rna), "\n")
cat("Patients with Mutation data:", length(patients_mut), "\n")
cat("Common patients for SNF:", length(common_patients), "\n")
```

**That means that each patient of which we have the genic expression, has also a mutation**

Matrix reorder (both matrices must have columns in the same order):

```{r}
# Expression Matrix (must be Patients x Genes but in 5a the dim was Genes x Patients
# and SNF needs the patients on the rows)
data_expression <- t(target_data[, common_patients])

# Mutation Matrix (Patients x Genes)
data_mutation <- mut_matrix_binary[common_patients, ]
```

Final check

```{r}
all(rownames(data_expression) == rownames(data_mutation)) # Must be TRUE
```

#### Calculation of Affinity Matrices

Standard parameters for SNF

```{r}
K <- 20      # number of neighbors
alpha <- 0.5 # hyperparameter for the construction of the affinity kernel
T_iter <- 20 # number of iteration needed for the fusion
```

First Layer: Expression

```{r}
dist_exp <- dist2(as.matrix(data_expression), as.matrix(data_expression)) # Euclidean distance 
W_exp <- affinityMatrix(dist_exp, K, alpha) # Affinity Matrix (W1)
```

Second Layer: Mutation

```{r}
dist_mut <- dist2(as.matrix(data_mutation), as.matrix(data_mutation)) # Euclidean distance
W_mut <- affinityMatrix(dist_mut, K, alpha) # Affinity Matrix (W2)
```

Fusion (Similarity Network Fusion)

```{r}
W_fused <- SNF(list(W_exp, W_mut), K, T_iter)
```

Assign the patient's names to the fused matrix

```{r}
rownames(W_fused) <- common_patients
colnames(W_fused) <- common_patients
```

#### Community Detection on the Fused Network

We apply Louvain clustering on the fused network to identify multi-omics communities.

Create the graph of the fused network:

```{r}
graph_snf <- graph_from_adjacency_matrix(W_fused, mode = "undirected", weighted = TRUE, diag = FALSE)
```

Apply Louvain

```{r}
louvain_snf <- cluster_louvain(graph_snf)
```

Create the dataframe of the SNF results

```{r}
comm_res_snf <- data.frame(
  patient = names(membership(louvain_snf)),
  community_snf = as.character(membership(louvain_snf)),
  stringsAsFactors = FALSE
)
```

Check

```{r}
cat("Number of communities found with SNF:", length(unique(comm_res_snf$community_snf)), "\n")
```

#### Plot of the Fused Network

Thresholding the matrix to improve readability

```{r}
l_comp_snf <- W_fused
threshold_snf <- 0.02
l_comp_snf[l_comp_snf < threshold_snf] <- 0
diag(l_comp_snf) <- 0
```

Network object

```{r}
net_snf <- network(l_comp_snf, matrix.type = "adjacency", ignore.eval = FALSE, names.eval = "weights", directed = FALSE)
```

Assign attributes

```{r}
net_names_snf <- network.vertex.names(net_snf)
net_snf %v% "community" <- comm_res_snf$community_snf[match(net_names_snf, comm_res_snf$patient)]

n_comm_snf <- length(unique(net_snf %v% "community"))
set.seed(123)
pal_snf <- sample(colors(distinct = TRUE), n_comm_snf)
names(pal_snf) <- sort(unique(net_snf %v% "community"))
```

Plot

```{r}
ggnet2(net_snf, 
       color = "community", 
       palette = pal_snf, 
       size = 6, 
       label = TRUE, 
       label.size = 3,
       edge.color = "gray90", 
       edge.alpha = 1) +
  ggtitle("SNF Community Structure (Expression + Mutation)")
```

#### Final comparison

Merge the results into a single dataframe

```{r}
comparison_df <- merge(comm_res, comm_res_snf, by = "patient")
colnames(comparison_df) <- c("Patient", "Cluster_RNA_Only", "Cluster_SNF")
```

Create a Confusion Matrix to show how patients move among groups when adding mutation data

```{r}
conf_matrix <- table(RNA_Only = comparison_df$Cluster_RNA_Only, 
                     SNF = comparison_df$Cluster_SNF)

print("Confusion Matrix (Rows: RNA Clusters, Cols: SNF Clusters):")
print(conf_matrix)
```

Transform the table in a dataframe for the plot

```{r}
melted_cmat <- as.data.frame(as.table(conf_matrix))
colnames(melted_cmat) <- c("RNA_Group", "SNF_Group", "Count")
```

Plot

```{r}
ggplot(melted_cmat, aes(x = SNF_Group, y = RNA_Group, fill = Count)) +
  geom_tile(color = "white") +
  geom_text(aes(label = Count), color = "black", size = 5) +
  scale_fill_gradient(low = "white", high = "tomato") +
  labs(title = "Comparison: RNA-Seq vs SNF Clusters",
       x = "SNF Communities (RNA + Mutation)",
       y = "RNA-Only Communities (5.1)") +
  theme_minimal() +
  theme(panel.grid.major = element_blank())
```

# PSN Communities Characterization (Clinical & Survival)

Stage 1 merges biological, clinical, and network-based information into a single patient-level table that will allow us to understand what defines each community and whether communities differ in survival or mutation patterns.

## 6. Clinical Data Integration

### Load libraries

```{r message=FALSE}
library(dplyr)
library(survival)
library(survminer)
library(maftools)
library(TCGAbiolinks)
library(stringr)
library(tidyr)


```

```{r}
length(unique(comm_res_snf$patient))
head(comm_res_snf)
```

```{r, results='hide'}
query_clin <- GDCquery(
  project = proj,
  data.category = "Clinical",
  data.type = "Clinical Supplement",
  data.format = "BCR XML"
)

# Only run once (then comment)
GDCdownload(query = query_clin)

clinical_kirp <- GDCprepare_clinic(query_clin, clinical.info = "patient")

```

```{r}
clinical_kirp <- clinical_kirp %>%
  mutate(
    patient = bcr_patient_barcode,
    survival_time = ifelse(!is.na(days_to_death),
                           days_to_death,
                           days_to_last_followup),
    survival_status = ifelse(vital_status == "Dead", 1, 0)
  ) %>%
  filter(!is.na(survival_time)) %>%
  select(patient, survival_time, survival_status, age_at_initial_pathologic_diagnosis, gender)
head(clinical_kirp)
```

```{r}
# Standardize patient column
comm_res$patient     <- substr(comm_res$patient, 1, 12)
comm_res_normal$patient <- substr(comm_res_normal$patient, 1, 12)
comm_res_snf$patient <- substr(comm_res_snf$patient, 1, 12)
clinical_kirp$patient <- substr(clinical_kirp$patient, 1, 12)

rownames(mut_matrix_binary) <- substr(rownames(mut_matrix_binary), 1, 12)
```

```{r}
str(mut_matrix_binary)  # patients × genes (0/1)
```

```{r}
DDR_genes  <- c("TP53", "ATM", "ATR", "BRCA1", "BRCA2", "CHEK1", "CHEK2")
TP53_path  <- c("TP53")
WNT_genes  <- c("APC", "CTNNB1", "AXIN1", "LRP5", "LRP6")
RTK_RAS_genes <- c("KRAS", "NRAS", "HRAS", "BRAF", "EGFR", "ERBB2")
PI3K_genes <- c("PIK3CA", "PTEN", "AKT1", "AKT2")

```

```{r}
DDR_genes      <- intersect(DDR_genes, colnames(mut_matrix_binary))
TP53_path      <- intersect(TP53_path, colnames(mut_matrix_binary))
WNT_genes      <- intersect(WNT_genes, colnames(mut_matrix_binary))
RTK_RAS_genes  <- intersect(RTK_RAS_genes, colnames(mut_matrix_binary))
PI3K_genes     <- intersect(PI3K_genes, colnames(mut_matrix_binary))
```

```{r}
pathway_matrix <- data.frame(
  patient = rownames(mut_matrix_binary),
  DDR      = as.integer(rowSums(mut_matrix_binary[, DDR_genes, drop = FALSE]) > 0),
  TP53     = as.integer(rowSums(mut_matrix_binary[, TP53_path, drop = FALSE]) > 0),
  WNT      = as.integer(rowSums(mut_matrix_binary[, WNT_genes, drop = FALSE]) > 0),
  RTK_RAS  = as.integer(rowSums(mut_matrix_binary[, RTK_RAS_genes, drop = FALSE]) > 0),
  PI3K     = as.integer(rowSums(mut_matrix_binary[, PI3K_genes, drop = FALSE]) > 0)
)

```

```{r}
tmb_res <- tmb(maf_obj)
tmb_df <- tmb_res %>%
  select(Tumor_Sample_Barcode, total_perMB) %>%
  mutate(
    patient = substr(Tumor_Sample_Barcode, 1, 12),
    TMB = total_perMB,
    TMB_high = TMB > 10
  ) %>%
  select(patient, TMB, TMB_high)

```

```{r}
clinical_kirp <- clinical_kirp %>%
  distinct(patient, .keep_all = TRUE)
clinical_kirp <- clinical_kirp %>% 
  filter(!is.na(survival_time), !is.na(survival_status))


```

```{r}
master_table <- comm_res_snf %>%
  rename(cluster_snf = community_snf) %>%
  
  # Add RNA-only PSN clusters
  left_join(comm_res %>% rename(cluster_rna = community),
            by = "patient") %>%
  
  # Add clinical survival data
  left_join(clinical_kirp,
            by = "patient") %>%
  
  # Add mutation pathway indicators
  left_join(pathway_matrix,
            by = "patient") %>%
  
  # Add TMB
  left_join(tmb_df,
            by = "patient")

```

```{r}
# Remove duplicates from master table
master_table <- master_table %>%
  distinct(patient, .keep_all = TRUE)
```

```{r}
cat("Number of patients in master table:", nrow(master_table), "\n")
head(master_table, 10)
summary(master_table)

```