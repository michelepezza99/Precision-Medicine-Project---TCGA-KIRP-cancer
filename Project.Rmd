---
title: "DEPM Project"
subtitle: "by Domenico Azzarito, Federico Lattanzio and Michele Pezza"
output: html_notebook
---

**Project Steps:**

1.  Selection of the disease: Kidney renal papillary cell carcinoma (KIRP)
2.  Differentially expressed genes (DEGs)
3.  CoExpression Networks
4.  Differential CoExpression Network
5.  Patient Similarity Network

```{r}
# TCGA-KIRP:
rm(list = ls())      # clear workspace
gc()                 # garbage collection
```

The first step is to loading the required packages for the analysis:

```{r message=FALSE}
library(BiocGenerics) # Contains generic Bioconductor functions used internally by SummarizedExperiment and DESeq2
library(DESeq2) # Store RNA-Seq counts and normalize counts
library(psych) # for correlation analysis
library(NetworkToolbox) # Additional functions for network analysis
library(ggplot2) # volcano plot, degree distribution plot and any additional plot
# library(ggnet)    
library(GGally) # Package containing ggnet2(), essential function for plotting
library(sna) # functions for clustering coefficient, components..
library(network) # defines the network() object type
library(TCGAbiolinks) # queries the GDC portal and downloads TCGA data
library(GenomicRanges)  # Gene annotation is stored as GRanges
library(SummarizedExperiment)  # TCGA RNA-Seq is stored in a SummarizedExperiment object
library(DT)  # Interactive visualization
library(igraph)
library(maftools)
library(SNFtool)
library(reshape2)

# sessionInfo()
```

## 1. Download data

We proceed to download the required tumor RNA-Seq data (Primary Tumor)

```{r message=FALSE}
proj <- "TCGA-KIRP"
dir.create(file.path(proj))
```

RNA-Seq data: primary tumor samples

```{r message=FALSE}
rna.query.C <- TCGAbiolinks::GDCquery(
  project = proj,
  data.category = "Transcriptome Profiling",
  data.type = "Gene Expression Quantification",
  workflow.type = "STAR - Counts",
  sample.type = "Primary Tumor"
)
```

Download the data from GDC to local cache folder "GDCdata" **(run only once)**

```{r message=FALSE}
# GDCdownload(query = rna.query.C, directory = "GDCdata", method = "api")
```

Convert the downloaded files into a SummarizedExperiment object

```{r message=FALSE}
rna.data.C <- GDCprepare(rna.query.C, directory = "GDCdata")
```

Extract the raw count matrix (genes x tumor samples)

```{r message=FALSE}
rna.expr.data.C <- assay(rna.data.C)
```

Extract gene annotation (Ensembl IDs, gene symbols, chromosomes, etc.)

```{r message=FALSE}
genes.info <- BiocGenerics::as.data.frame(rowRanges(rna.data.C))
```

Checks:

```{r message=FALSE}
head(rna.query.C$results[[1]]$cases)
rna.data.C
dim(rna.expr.data.C)
head(genes.info)

```

Download normal samples

```{r message=FALSE}
# RNA-Seq data: solid tissue normal samples
rna.query.N <- TCGAbiolinks::GDCquery(
  project = proj,
  data.category = "Transcriptome Profiling",
  data.type = "Gene Expression Quantification",
  workflow.type = "STAR - Counts",
  sample.type = "Solid Tissue Normal"
)
```

Download normal data

```{r message=FALSE}
GDCdownload(query = rna.query.N, directory = "GDCdata", method = "api")
```

Prepare SummarizedExperiment for normal samples

```{r message=FALSE}
rna.data.N <- GDCprepare(rna.query.N, directory = "GDCdata")
```

Extract raw counts for normal samples

```{r message=FALSE}
rna.expr.data.N <- assay(rna.data.N)
```

Extract gene annotation for normal dataset

```{r}
genes.info2 <- BiocGenerics::as.data.frame(rowRanges(rna.data.N))
```

Sanity check: tumor and normal gene annotations should match

```{r}
all(na.omit(genes.info2) == na.omit(genes.info))
```

Checks:

```{r}
dim(rna.expr.data.N)
rna.data.N
```

Results:

-   Tumor: 60,660 genes × 290 samples

-   Normal: 60,660 genes × 32 samples

-   Gene annotation: identical between tumor and normal

### Clinical Data (To be done, not needed now)

```{r}

```

### Data cleaning

#### Inspect basic structure

Dimensions: genes x samples

```{r}
dim(rna.expr.data.C)  # tumor
dim(rna.expr.data.N)  # normal
```

Quick look at column names (TCGA barcodes)

```{r}
head(colnames(rna.expr.data.C))
head(colnames(rna.expr.data.N))
```

Extract patient IDs (first 12 characters of barcode)

```{r}
patients.C <- substr(colnames(rna.expr.data.C), 1, 12)
patients.N <- substr(colnames(rna.expr.data.N), 1, 12)
```

How many unique patients in each group?

```{r}
length(unique(patients.C))
length(unique(patients.N))
```

Distribution of tumor samples per patient (to detect duplicates)

```{r}
sort(table(patients.C))
```

#### Keep only patients with exactly ONE tumor sample

Table: how many tumor samples per patient

```{r}
tab.C <- table(patients.C)
```

Select patient IDs with exactly 1 primary tumor sample

```{r}
single.C <- names(tab.C[tab.C == 1])
```

Indices of columns in tumor matrix corresponding to single-sample patients

```{r}
idx.single.C <- which(patients.C %in% single.C)
```

Tumor expression matrix: only one tumor sample per patient

```{r}
expr.C <- as.data.frame(rna.expr.data.C[, idx.single.C])
```

Normal expression matrix: start with all normals

```{r}
expr.N <- as.data.frame(rna.expr.data.N)
```

#### Rename columns to pure patient IDs

Use only the 12-character patient ID as column names

```{r}
colnames(expr.C) <- substr(colnames(expr.C), 1, 12) 
colnames(expr.N) <- substr(colnames(expr.N), 1, 12)
```

quick check

```{r}
head(colnames(expr.C))
head(colnames(expr.N))
```

Make sure there are no duplicated column names now

```{r}
sum(duplicated(colnames(expr.C)))
sum(duplicated(colnames(expr.N)))
```

#### Keep only patients with BOTH tumor and normal samples

Patient IDs present in BOTH expr.C (tumor) and expr.N (normal)

```{r}
common_ids <- intersect(colnames(expr.C), colnames(expr.N))
length(common_ids) # this is the number of paired patients
```

Subset both matrices to the same set of patients

```{r}
expr.C <- expr.C[, common_ids, drop = FALSE] 
expr.N <- expr.N[, common_ids, drop = FALSE]
```

Sanity checks

```{r}
ncol(expr.C) # number of paired tumor samples 
ncol(expr.N) # number of paired normal samples 
all(colnames(expr.C) == colnames(expr.N)) # should be TRUE
```

#### Final technical checks on counts

Check that genes (rows) are aligned between tumor and normal

```{r}
all(rownames(expr.C) == rownames(expr.N)) # must be TRUE
```

Check data types and missingness

```{r}
typeof(expr.C[1, 1])            # should be "integer" or "double" 
any(is.na(expr.C))              # should be FALSE 
any(is.nan(as.matrix(expr.C)))  # should be FALSE

typeof(expr.N[1, 1]) 
any(is.na(expr.N)) 
any(is.nan(as.matrix(expr.N)))
```

At this point:

-   expr.C = raw tumor counts, genes x N_paired patients

-   expr.N = raw normal counts, genes x N_paired patients

-   Columns in expr.C and expr.N are the SAME patients, SAME order

These are the matrices we will feed into DESeq2 for normalization.

### Normalizing data with DESeq2

Check alignment of tumor and normal matrices

```{r}
all(rownames(expr.C) == rownames(expr.N)) # Must be TRUE (same gene order)
```

Combine into full dataset: normals first, then tumors

```{r}
full.data <- cbind(expr.N, expr.C) 
full.data <- data.frame(full.data)

dim(full.data) # should be 60660 x 64 (32 normal + 32 tumor)
```

### Build metadata

```{r}
metad <- data.frame( 
    condition = factor(c( 
        rep("normal", ncol(expr.N)), 
        rep("cancer", ncol(expr.C)) 
    )) 
)
```

Row names must match full.data column names

```{r}
rownames(metad) <- colnames(full.data)
```

DESeq2 expects gene_id as a column when tidy=TRUE

```{r}
full.data <- cbind(gene_id = rownames(full.data), full.data)
```

### Build DESeq2 dataset

```{r}
dds <- DESeqDataSetFromMatrix( 
    countData = full.data, 
    colData = metad, 
    design = ~ condition, 
    tidy = TRUE 
)
```

Sanity check

```{r}
dim(counts(dds)) # should be 60660 x 64
```

### Filter low-expression genes

At least 10 counts in 90% of patients for each group

We have 32 normal and 32 cancer → threshold = 0.90 \* 32 ≈ 28.8 → floor = 28

```{r}
threshold <- floor(0.9 * ncol(expr.N)) # = 28

keep <- rowSums(counts(dds) >= 10) >= threshold 
dds <- dds[keep, ]

dim(counts(dds)) # reduced number of genes
```

### Normalize using DESeq2 size factors

```{r}
dds <- estimateSizeFactors(dds)

normalized_counts <- counts(dds, normalized = TRUE)

# No gene should be zero in all samples
sum(rowSums(normalized_counts == 0) == ncol(normalized_counts))
```

### Split normalized matrix back into normal/tumor

```{r}
filtr.expr.n <- as.data.frame( 
    normalized_counts[, 1:ncol(expr.N)] 
)

filtr.expr.c <- as.data.frame( 
    normalized_counts[, (ncol(expr.N) + 1):ncol(normalized_counts)] 
)
```

Keep original patient IDs (DESeq2 sometimes adds .1, .2)

```{r}
colnames(filtr.expr.n) <- colnames(expr.N) 
colnames(filtr.expr.c) <- colnames(expr.C)
```

### Final checks

```{r}
# Same genes
all(rownames(filtr.expr.c) == rownames(filtr.expr.n))

# Same patients
all(colnames(filtr.expr.c) == colnames(filtr.expr.n))

nrow(filtr.expr.c)   # number of filtered/normalized genes
ncol(filtr.expr.c)   # should be 32

sizeFactors(dds)
summary(sizeFactors(dds))
```

**Output:**

-   **filtr.expr.n = normalized expression for 32 normal samples**

-   **filtr.expr.c = normalized expression for 32 tumor samples**

These matrices are what we will use for:

-   DEGs

-   Volcano Plot

-   Co-expression networks

-   Differential networks

-   PSN and SNF

## 2. Differential Expression Analysis (DEGs) — UPDATED THRESHOLDS

### Compute log2 Fold Change

```{r}
log2fc <- log2(rowMeans(filtr.expr.c) / rowMeans(filtr.expr.n))
names(log2fc) <- rownames(filtr.expr.c)
```

### Compute paired t-test p-values

```{r}
pval <- sapply(
  1:nrow(filtr.expr.c),
  function(i) t.test(
    as.numeric(filtr.expr.c[i, ]),
    as.numeric(filtr.expr.n[i, ]),
    paired = TRUE
  )$p.value
)
```

### FDR correction

```{r}
pval_fdr <- p.adjust(pval, method = "fdr")
```

### Build DEG table

```{r}
deg.table <- data.frame(
  gene        = rownames(filtr.expr.c),
  log2FC      = log2fc,
  pvalue      = pval,
  pvalue_fdr  = pval_fdr,
  row.names   = rownames(filtr.expr.c)
)
```

### Apply NEW thresholds

```{r}
FDR_threshold <- 0.001
FC_threshold  <- 2.0

deg.genes <- subset(
  deg.table,
  abs(log2FC) >= FC_threshold & pvalue_fdr <= FDR_threshold
)

cat("Number of DEGs:", nrow(deg.genes), "\n")
```

### Volcano plot

```{r}
deg.table$color <- "NO"
deg.table$color[deg.table$log2FC >= FC_threshold & deg.table$pvalue_fdr <= FDR_threshold] <- "UP"
deg.table$color[deg.table$log2FC <= -FC_threshold & deg.table$pvalue_fdr <= FDR_threshold] <- "DOWN"
deg.table$color <- factor(deg.table$color, levels = c("DOWN", "NO", "UP"))

ggplot(deg.table, aes(x = log2FC, y = -log10(pvalue_fdr), color = color)) +
  geom_point(alpha = 0.6) +
  xlab("log2 Fold Change") +
  ylab("-log10 FDR") +
  geom_vline(xintercept = c(-FC_threshold, FC_threshold), col = "red") +
  geom_hline(yintercept = -log10(FDR_threshold), col = "red") +
  theme_minimal()


DEG_list <- rownames(deg.genes)
length(DEG_list)
```

## 3. CoExpression Networks

### Extract the DEG expression matrices

Keep only DEGs in the normalized matrices

```{r}
expr_deg_cancer <- filtr.expr.c[DEG_list, ]
expr_deg_normal <- filtr.expr.n[DEG_list, ]
```

Log transform (as asked by the professor)

```{r}
expr_deg_cancer <- log2(expr_deg_cancer + 1)
expr_deg_normal <- log2(expr_deg_normal + 1)
```

Check dimensions

```{r}
dim(expr_deg_cancer)
dim(expr_deg_normal)
```

The number of columns must be 32 in both and the number of rows must match number of DEGs

```{r}
all(rownames(expr_deg_cancer) == rownames(expr_deg_normal))
```

### Compute adjacency matrices for cancer and normal

Set correlation threshold

```{r}
corr_threshold <- 0.7
```

### Compute adjacency matrices for cancer and normal

Cancer network (cor is faster then test.corr if you have only to compute the rho as here)

```{r}
cor_mat_c <- cor(t(expr_deg_cancer), method = "pearson")  # Pearson correlation
diag(cor_mat_c) <- 0  # Remove self-correlations
adj_mat_c <- (abs(cor_mat_c) >= corr_threshold) * 1 # Binary adjacency
```

Normal network

```{r}
cor_mat_n <- cor(t(expr_deg_normal), method = "pearson")
diag(cor_mat_n) <- 0
adj_mat_n <- (abs(cor_mat_n) >= corr_threshold) * 1
```

### Compute degree for each network

```{r}
degree_c <- colSums(adj_mat_c != 0)
names(degree_c) <- rownames(adj_mat_c)
degree_c <- sort(degree_c, decreasing = TRUE)

degree_n <- colSums(adj_mat_n != 0)
names(degree_n) <- rownames(adj_mat_n)
degree_n <- sort(degree_n, decreasing = TRUE)
```

### Check if scale-free network (plot degree distribution)

Cancer Network degree distribution

```{r}
hist(degree_c, breaks = 50, main = "Cancer Network Degree Distribution",
     xlab = "Degree", col = "lightblue", freq = FALSE)
```

To check scale-free: plot log-log (degree vs frequency)

```{r}
deg_freq_c <- table(degree_c)
plot(log(as.numeric(names(deg_freq_c))), log(deg_freq_c), 
     main = "Cancer: Log-Log Degree Distribution", xlab = "log(Degree)", ylab = "log(Frequency)", 
     pch = 16, col = "blue")
```

Normal Network degree distribution

```{r}
hist(degree_n, breaks = 50, main = "Normal Network Degree Distribution",
     xlab = "Degree", col = "lightgreen", freq = FALSE)

deg_freq_n <- table(degree_n)
plot(log(as.numeric(names(deg_freq_n))), log(deg_freq_n), 
     main = "Normal: Log-Log Degree Distribution", xlab = "log(Degree)", ylab = "log(Frequency)", 
     pch = 16, col = "green")
```

### Find hubs (top 5% highest degree)

```{r}
y <- quantile(degree_n[degree_n>0], 0.95)
x <- quantile(degree_c[degree_c>0], 0.95)

hubs_c <- degree_c[degree_c>=x]

hubs_n <- degree_n[degree_n>=y]
```

### Compare hubs between conditions

Common hubs

```{r}
common_hubs <- intersect(names(hubs_c), names(hubs_n))
```

Hubs unique to cancer

```{r}
selective_hubs_c <- setdiff(names(hubs_c), names(hubs_n))
```

Hubs unique to normal

```{r}
selective_hubs_n <- setdiff(names(hubs_n), names(hubs_c))
```

Output

```{r}
cat("Number of cancer hubs:", length(hubs_c), "\n")
cat("Number of normal hubs:", length(hubs_n), "\n")
cat("Number of common hubs:", length(common_hubs), "\n")
cat("Number of selective hubs in cancer:", length(selective_hubs_c), "\n")
cat("Number of selective hubs in normal:", length(selective_hubs_n), "\n")
```

**Output:**

-   **adj_mat_c = adjacency matrix for cancer co-expression network**

-   **adj_mat_n = adjacency matrix for normal co-expression network**

-   **hubs_c = hubs in cancer network**

-   **hubs_n = hubs in normal network**

## 4. Differential Co-expressed Network

Set Z-score threshold

```{r}
z_threshold <- 4 # SCELTO PIU' RESTRITTIVO PER FAR VENIRE RETE MENO DENSA -\> POWER-LAW +-
```

Sample sizes

```{r}
n_c <- ncol(expr_deg_cancer)  # Number of cancer samples
n_n <- ncol(expr_deg_normal)  # Number of normal samples
```

### Compute differential adjacency matrix

Function to compute Fisher's Z-transform

```{r}
fisher_z <- function(r) {
  0.5 * log((1 + r) / (1 - r))
}
```

Compute Z-transforms for cancer and normal correlations

```{r}
z_c <- fisher_z(cor_mat_c)
z_n <- fisher_z(cor_mat_n)
```

Compute Z-score for difference: (z_c - z_n) / sqrt(1/(n_c-3) + 1/(n_n-3))

```{r}
se <- sqrt(1/(n_c - 3) + 1/(n_n - 3))
z_diff <- (z_c - z_n) / se
```

Binary adjacency

```{r}
adj_mat_diff <- z_diff
adj_mat_diff <- adj_mat_diff_bin <- (abs(z_diff) >= z_threshold) * 1
```

Remove diagonal

```{r}
diag(adj_mat_diff) <- 0
```

### Compute degree for differential network

```{r}
degree_diff <- colSums(adj_mat_diff != 0)
names(degree_diff) <- rownames(adj_mat_diff)
degree_diff <- sort(degree_diff, decreasing = TRUE)
```

### Check if scale-free network (plot degree distribution)

Differential network degree distribution

```{r}
hist(degree_diff, breaks = 50, main = "Differential Network Degree Distribution", 
     xlab = "Degree", col = "lightcoral", freq = FALSE)
```

Log-log plot

```{r}
deg_freq_diff <- table(degree_diff)
if (length(deg_freq_diff) > 1) {
  plot(log(as.numeric(names(deg_freq_diff))), log(deg_freq_diff), 
       main = "Differential: Log-Log Degree Distribution", xlab = "log(Degree)", ylab = "log(Frequency)", 
       pch = 16, col = "red")
}
```

### Find hubs (top 5% highest degree)

```{r}
z <- quantile(degree_diff[degree_diff>0], 0.95)
hubs_diff <- degree_diff[degree_diff>=z]
```

### Compare hubs with task 3 (cancer and normal hubs)

Common with cancer hubs

```{r}
common_hubs_diff_c <- intersect(names(hubs_diff), names(hubs_c))
```

Common with normal hubs

```{r}
common_hubs_diff_n <- intersect(names(hubs_diff), names(hubs_n))
```

Unique to differential

```{r}
selective_hubs_diff <- setdiff(names(hubs_diff), union(names(hubs_c), names(hubs_n)))
```

Output

```{r}
cat("Number of differential hubs:", length(hubs_diff), "\n")
cat("Number of hubs common with cancer:", length(common_hubs_diff_c), "\n")
cat("Number of hubs common with normal:", length(common_hubs_diff_n), "\n")
cat("Number of selective hubs in differential:", length(selective_hubs_diff), "\n")
```

### Subnetwork Plot of the Most Relevant Gene (Highest Degree in Differential Network)

Find the gene with the highest degree in the differential network

```{r}
top_gene <- names(degree_diff)[1]  # Highest degree
top_gene_degree <- degree_diff[1]

cat("Most relevant gene:", top_gene, "with degree:", top_gene_degree, "\n")
```

Find neighbors: genes connected to top_gene in adj_mat_diff

```{r}
neighbors <- which(adj_mat_diff[top_gene, ] != 0)
neighbor_names <- colnames(adj_mat_diff)[neighbors]
```

Subset: top_gene and its neighbors

```{r}
subnet_nodes <- unique(c(top_gene, neighbor_names))
subnet_adj <- adj_mat_diff[subnet_nodes, subnet_nodes]
```

Create network object

```{r}
net_subnet <- network(subnet_adj, matrix.type = "adjacency", ignore.eval = FALSE, names.eval = "weights", directed = FALSE)
```

Set attributes for plotting

```{r}
net_subnet %v% "type" <- ifelse(network.vertex.names(net_subnet) == top_gene, "top_gene", "neighbor")
net_subnet %v% "color" <- ifelse(net_subnet %v% "type" == "top_gene", "red", "blue")
network::set.edge.attribute(net_subnet, "edgecolor", "green") 
```

Plot subnetwork

```{r}
ggnet2(net_subnet, color = "color", alpha = 0.7, size = 3,
       edge.color = "edgecolor", edge.alpha = 1, edge.size = 0.5,
       node.label = NULL, label.color = "black", label.size = 4) +
  ggtitle(paste("Subnetwork of", top_gene, "(Highest Degree in Differential Network)")) +
  guides(size = "none")
```

**Output:**

-   **adj_mat_diff = adjacency matrix for differential co-expression network**

-   **hubs_diff = hubs in differential network**

## 5. Patient Similarity Network (PSN)

### a. Computation of the PSN

#### Data preparation

```{r}
# we use expr_deg_cancer because it contains normalized and log-transoformed data
# dds or rna.expr.data.C are raw counts so if used well expressed genes would end up dominating the calculation
target_data <- as.matrix(expr_deg_cancer)
```

Check dimension

```{r}
print(dim(target_data)) # we expect N_DEGs x 32 patients
```

#### Calculation of the similarity matrix

Calculate Pearson correlation between patients (columns)

```{r}
patient_sim_matrix <- cor(target_data, method = "pearson")
```

#### Clean-up of the matrix

Set the diagonal to 0 to remove self-loops

```{r}
diag(patient_sim_matrix) <- 0
dim(patient_sim_matrix)
```

#### Manage negative correlations

We're only intrested in positive correlations

```{r}
patient_sim_matrix[patient_sim_matrix<0] <- 0
```

#### Create the network object

```{r}
psn_graph <- graph_from_adjacency_matrix(
  patient_sim_matrix,
  mode = "undirected",
  weighted = TRUE,
  diag = FALSE
)
```

#### Check of the graph

```{r}
cat("# of nodes (patients):", vcount(psn_graph), "\n")
cat("# of edges:", ecount(psn_graph), "\n")
```

Plot of the PSN

```{r}
# creates a network object because ggnet2 needs it for plotting
# otherwise by passing an igraph object such as psn_graph, it would need an additional library
net_obj <- network(patient_sim_matrix, 
                   matrix.type = "adjacency", 
                   ignore.eval = FALSE,    # keeps weights
                   names.eval = "weights", 
                   directed = FALSE)

ggnet2(net_obj,
       size = 6,
       color = "orange",
       label = TRUE,
       label.size = 3,
       label.color = "black",
       edge.size = "weights",      
       edge.color = "gray80"
) +
  ggtitle("Patient Similarity Network")
```

### b. Community detection

#### Applying the Louvain Algorithm

```{r}
louvain_cl <- cluster_louvain(psn_graph)
```

#### Create the result dataframe

```{r}
comm_res <- data.frame(
  patient = names(membership(louvain_cl)),
  community = as.character(membership(louvain_cl)),
  stringsAsFactors = FALSE
)
```

#### Network Preparation for Plotting

Filter the matrix by applying a threshold to keep only the strongest conenctions

```{r}
l_comp <- patient_sim_matrix

# Apply a threshold
threshold_plot <- 0.7 
l_comp[abs(l_comp) < threshold_plot] <- 0
diag(l_comp) <- 0
```

```{r}
net_final <- network(l_comp, 
                     matrix.type = "adjacency", 
                     ignore.eval = FALSE, 
                     names.eval = "weights", 
                     directed = FALSE)
```

#### Assigning attributes

```{r}
net_names <- network.vertex.names(net_final)
net_final %v% "community" <- comm_res$community[match(net_names, comm_res$patient)]
network::set.edge.attribute(net_final, "edgecolor", "gray90")
```

#### Check how many communities we have

```{r}
n_communities <- length(unique(net_final %v% "community"))
cat("Number of communities found:", n_communities, "\n")
```

#### Plot

```{r}
# Create colour palette (Dynamic based on number of communities)
set.seed(13)
# Sample distinct colors
pal <- sample(colors(distinct = TRUE), n_communities)
names(pal) <- sort(unique(net_final %v% "community"))

ggnet2(net_final, 
       color = "community", 
       palette = pal, 
       alpha = 0.9, 
       size = 6, 
       label = TRUE,               # patient IDs
       label.size = 3,
       edge.color = "edgecolor", 
       edge.alpha = 0.8, 
       edge.size = 0.3) +
  guides(size = "none") +
  ggtitle("PSN Community Structure (Louvain)")
```

### c. Similarity Network Fusion

#### Download & Processing of Mutation Data

We download the Simple Nucleotide Variation data for TCGA-KIRP and convert it into a binary mutation matrix.

```{r message=FALSE}
query_mut <- TCGAbiolinks::GDCquery(
  project = proj, 
  data.category = "Simple Nucleotide Variation", 
  data.type = "Masked Somatic Mutation",
  workflow.type = "Aliquot Ensemble Somatic Variant Merging and Masking" # current standard 
)
```

Actual download **run only once**

```{r message=FALSE}
#GDCdownload(query = query_mut, directory = "GDCdata", method = "api")
```

Convert the downloaded files into a SummarizedExperiment object

```{r message=FALSE}
mut_data_prepared <- GDCprepare(query_mut)
```

Reading with maftools

```{r}
maf_obj <- read.maf(maf = mut_data_prepared)
```

Create the bianry matrix (Patients x Genes)

```{r}
mut_count_matrix <- mutCountMatrix(maf_obj) # matrix with the count of the mutations
```

Transpose the matrix in order to have patients on the rows and genes on the columns

```{r}
mut_matrix_binary <- t(mut_count_matrix)
```

Convert in binary (1 if mutated, 0 otherwise)

```{r}
mut_matrix_binary[mut_matrix_binary > 0] <- 1
```

Use only the 12-character patient ID as row names

```{r}
rownames(mut_matrix_binary) <- substr(rownames(mut_matrix_binary), 1, 12)
```

Remove possible duplicates

```{r}
mut_matrix_binary <- mut_matrix_binary[!duplicated(rownames(mut_matrix_binary)), ]
```

#### Patient Alignment (Expression vs Mutation)

We need to ensure both matrices analyze exactly the same set of patients.

```{r}
patients_rna <- substr(colnames(target_data), 1, 12) # patients used in the 5a section (expression)
patients_mut <- rownames(mut_matrix_binary) # patients available in mutations
```

Find the intersection (common patients)

```{r}
common_patients <- intersect(patients_rna, patients_mut)
```

Quick check

```{r}
cat("Esempio RNA:", head(patients_rna, 3), "\n")
cat("Esempio MUT:", head(patients_mut, 3), "\n\n")

cat("Patients with RNA data:", length(patients_rna), "\n")
cat("Patients with Mutation data:", length(patients_mut), "\n")
cat("Common patients for SNF:", length(common_patients), "\n")
```

**That means that each patient of which we have the genic expression, has also a mutation**

Matrix reorder (both matrices must have columns in the same order):

```{r}
# Expression Matrix (must be Patients x Genes but in 5a the dim was Genes x Patients
# and SNF needs the patients on the rows)
data_expression <- t(target_data[, common_patients])

# Mutation Matrix (Patients x Genes)
data_mutation <- mut_matrix_binary[common_patients, ]
```

Final check

```{r}
all(rownames(data_expression) == rownames(data_mutation)) # Must be TRUE
```

#### Calculation of Affinity Matrices

Standard parameters for SNF

```{r}
K <- 20      # number of neighbors
alpha <- 0.5 # hyperparameter for the construction of the affinity kernel
T_iter <- 20 # number of iteration needed for the fusion
```

First Layer: Expression

```{r}
dist_exp <- dist2(as.matrix(data_expression), as.matrix(data_expression)) # Euclidean distance 
W_exp <- affinityMatrix(dist_exp, K, alpha) # Affinity Matrix (W1)
```

Second Layer: Mutation

```{r}
dist_mut <- dist2(as.matrix(data_mutation), as.matrix(data_mutation)) # Euclidean distance
W_mut <- affinityMatrix(dist_mut, K, alpha) # Affinity Matrix (W2)
```

Fusion (Similarity Network Fusion)

```{r}
W_fused <- SNF(list(W_exp, W_mut), K, T_iter)
```

Assign the patient's names to the fused matrix

```{r}
rownames(W_fused) <- common_patients
colnames(W_fused) <- common_patients
```

#### Community Detection on the Fused Network

We apply Louvain clustering on the fused network to identify multi-omics communities.

Create the graph of the fused network:

```{r}
graph_snf <- graph_from_adjacency_matrix(W_fused, mode = "undirected", weighted = TRUE, diag = FALSE)
```

Apply Louvain

```{r}
louvain_snf <- cluster_louvain(graph_snf)
```

Create the dataframe of the SNF results

```{r}
comm_res_snf <- data.frame(
  patient = names(membership(louvain_snf)),
  community_snf = as.character(membership(louvain_snf)),
  stringsAsFactors = FALSE
)
```

Check

```{r}
cat("Number of communities found with SNF:", length(unique(comm_res_snf$community_snf)), "\n")
```

#### Plot of the Fused Network

Thresholding the matrix to improve readability

```{r}
l_comp_snf <- W_fused
threshold_snf <- 0.02
l_comp_snf[l_comp_snf < threshold_snf] <- 0
diag(l_comp_snf) <- 0
```

Network object

```{r}
net_snf <- network(l_comp_snf, matrix.type = "adjacency", ignore.eval = FALSE, names.eval = "weights", directed = FALSE)
```

Assign attributes

```{r}
net_names_snf <- network.vertex.names(net_snf)
net_snf %v% "community" <- comm_res_snf$community_snf[match(net_names_snf, comm_res_snf$patient)]

n_comm_snf <- length(unique(net_snf %v% "community"))
set.seed(123)
pal_snf <- sample(colors(distinct = TRUE), n_comm_snf)
names(pal_snf) <- sort(unique(net_snf %v% "community"))
```

Plot

```{r}
ggnet2(net_snf, 
       color = "community", 
       palette = pal_snf, 
       size = 6, 
       label = TRUE, 
       label.size = 3,
       edge.color = "gray90", 
       edge.alpha = 1) +
  ggtitle("SNF Community Structure (Expression + Mutation)")
```

#### Final comparison

Merge the results into a single dataframe

```{r}
comparison_df <- merge(comm_res, comm_res_snf, by = "patient")
colnames(comparison_df) <- c("Patient", "Cluster_RNA_Only", "Cluster_SNF")
```

Create a Confusion Matrix to show how patients move among groups when adding mutation data

```{r}
conf_matrix <- table(RNA_Only = comparison_df$Cluster_RNA_Only, 
                     SNF = comparison_df$Cluster_SNF)

print("Confusion Matrix (Rows: RNA Clusters, Cols: SNF Clusters):")
print(conf_matrix)
```

Transform the table in a dataframe for the plot
```{r}
melted_cmat <- as.data.frame(as.table(conf_matrix))
colnames(melted_cmat) <- c("RNA_Group", "SNF_Group", "Count")
```


Plot
```{r}
ggplot(melted_cmat, aes(x = SNF_Group, y = RNA_Group, fill = Count)) +
  geom_tile(color = "white") +
  geom_text(aes(label = Count), color = "black", size = 5) +
  scale_fill_gradient(low = "white", high = "tomato") +
  labs(title = "Comparison: RNA-Seq vs SNF Clusters",
       x = "SNF Communities (RNA + Mutation)",
       y = "RNA-Only Communities (5.1)") +
  theme_minimal() +
  theme(panel.grid.major = element_blank())
```

