---
title: "DEPM Project"
subtitle: "by Domenico Azzarito, Federico Lattanzio and Michele Pezza"
output: html_notebook
---

**Project Steps:**

1.  Selection of the disease: Kidney renal papillary cell carcinoma (KIRP)
2.  Differentially expressed genes (DEGs)
3.  CoExpression Networks
4.  Differential CoExpression Network
5.  Patient Similarity Network

```{r, results='hide'}
# TCGA-KIRP:
rm(list = ls())      # clear workspace
gc()                 # garbage collection
```

The first step is to loading the required packages for the analysis:

```{r message=FALSE}
library(BiocGenerics) # Contains Bioconductor generics used internally by SummarizedExperiment and DESeq2
library(DESeq2) # Store RNA-Seq counts and normalize counts
library(psych) # correlation analysis + p-value adjustment
library(NetworkToolbox) # Additional functions for network analysis
library(ggplot2) # volcano plot, degree distribution plot and any additional plot
# library(ggnet)    
library(GGally) # Package containing ggnet2(), essential function for plotting
library(sna) # functions for clustering coefficient, components..
library(network) # defines the network() object type
library(TCGAbiolinks) # queries the GDC portal and downloads TCGA data
library(GenomicRanges)  # Gene annotation is stored as GRanges
library(SummarizedExperiment)  # TCGA RNA-Seq is stored in a SummarizedExperiment object
library(DT)  # Interactive visualization
library(igraph)
library(maftools)
library(SNFtool)
library(reshape2)
library(poweRlaw)
# sessionInfo()
```

## 1. Download data

We proceed to download the required tumor RNA-Seq data (Primary Tumor)

```{r message=FALSE, results='hide'}
proj <- "TCGA-KIRP"
dir.create(file.path(proj))
```

RNA-Seq data: primary tumor samples

```{r message=FALSE}
rna.query.C <- TCGAbiolinks::GDCquery(
  project = proj,
  data.category = "Transcriptome Profiling",
  data.type = "Gene Expression Quantification",
  workflow.type = "STAR - Counts",
  sample.type = "Primary Tumor"
)
```

Download the data from GDC to local cache folder "GDCdata" a

```{r message=FALSE}
GDCdownload(query = rna.query.C, directory = "GDCdata", method = "api")
```

Convert the downloaded files into a SummarizedExperiment object

```{r message=FALSE, results='hide'}
rna.data.C <- GDCprepare(rna.query.C, directory = "GDCdata")
```

Extract the raw count matrix (genes x tumor samples)

```{r message=FALSE}
rna.expr.data.C <- assay(rna.data.C)
```

Extract gene annotation (Ensembl IDs, gene symbols, chromosomes, etc.)

```{r message=FALSE}
genes.info <- BiocGenerics::as.data.frame(rowRanges(rna.data.C))
```

Checks:

```{r message=FALSE}
head(rna.query.C$results[[1]]$cases)
rna.data.C
dim(rna.expr.data.C)
head(genes.info)

```

Download normal samples

```{r message=FALSE}
# RNA-Seq data: solid tissue normal samples
rna.query.N <- TCGAbiolinks::GDCquery(
  project = proj,
  data.category = "Transcriptome Profiling",
  data.type = "Gene Expression Quantification",
  workflow.type = "STAR - Counts",
  sample.type = "Solid Tissue Normal"
)
```

Download normal data

```{r message=FALSE}
GDCdownload(query = rna.query.N, directory = "GDCdata", method = "api")
```

Prepare SummarizedExperiment for normal samples

```{r message=FALSE, results='hide'}
rna.data.N <- GDCprepare(rna.query.N, directory = "GDCdata")
```

Extract raw counts for normal samples

```{r message=FALSE}
rna.expr.data.N <- assay(rna.data.N)
```

Extract gene annotation for normal dataset

```{r}
genes.info2 <- BiocGenerics::as.data.frame(rowRanges(rna.data.N))
```

Sanity check: tumor and normal gene annotations should match

```{r}
all(na.omit(genes.info2) == na.omit(genes.info))
```

Checks:

```{r}
dim(rna.expr.data.N)
rna.data.N
```

Results:

-   Tumor: 60,660 genes × 290 samples

-   Normal: 60,660 genes × 32 samples

-   Gene annotation: identical between tumor and normal

### Data cleaning

#### Inspect basic structure

Dimensions: genes x samples

```{r}
dim(rna.expr.data.C)  # tumor
dim(rna.expr.data.N)  # normal
```

Quick look at column names (TCGA barcodes)

```{r}
head(colnames(rna.expr.data.C))
head(colnames(rna.expr.data.N))
```

Extract patient IDs (first 12 characters of barcode)

```{r}
patients.C <- substr(colnames(rna.expr.data.C), 1, 12)
patients.N <- substr(colnames(rna.expr.data.N), 1, 12)
```

How many unique patients in each group?

```{r}
length(unique(patients.C))
length(unique(patients.N))
```

Distribution of tumor samples per patient (to detect duplicates)

```{r,results='hide'}
sort(table(patients.C))
```

#### Keep only patients with exactly ONE tumor sample

Table: how many tumor samples per patient

```{r}
tab.C <- table(patients.C)
```

Select patient IDs with exactly 1 primary tumor sample

```{r}
single.C <- names(tab.C[tab.C == 1])
```

Indices of columns in tumor matrix corresponding to single-sample patients

```{r}
idx.single.C <- which(patients.C %in% single.C)
```

Tumor expression matrix: only one tumor sample per patient

```{r}
expr.C <- as.data.frame(rna.expr.data.C[, idx.single.C])
```

Normal expression matrix: start with all normals

```{r}
expr.N <- as.data.frame(rna.expr.data.N)
```

#### Rename columns to pure patient IDs

Use only the 12-character patient ID as column names

```{r}
colnames(expr.C) <- substr(colnames(expr.C), 1, 12) 
colnames(expr.N) <- substr(colnames(expr.N), 1, 12)
```

quick check

```{r}
head(colnames(expr.C))
head(colnames(expr.N))
```

Make sure there are no duplicated column names now

```{r}
sum(duplicated(colnames(expr.C)))
sum(duplicated(colnames(expr.N)))
```

#### Keep only patients with BOTH tumor and normal samples

Patient IDs present in BOTH expr.C (tumor) and expr.N (normal)

```{r}
common_ids <- intersect(colnames(expr.C), colnames(expr.N))
length(common_ids) # this is the number of paired patients
```

Subset both matrices to the same set of patients

```{r}
expr.C <- expr.C[, common_ids, drop = FALSE] 
expr.N <- expr.N[, common_ids, drop = FALSE]
```
#### Remove genes with zero counts in ANY sample
We remove genes that have zero counts in at least one sample (tumor or normal) since they do not provide useful information for differential expression analysis and we aim to avoid mathematical issues during log fold change calculations.
```{r}
nonzero_genes <- rowSums(expr.C == 0) == 0 & rowSums(expr.N == 0) == 0

expr.C <- expr.C[nonzero_genes, ]
expr.N <- expr.N[nonzero_genes, ]

cat("Genes kept:", sum(nonzero_genes), "\n")

```

Sanity checks

```{r}
ncol(expr.C) # number of paired tumor samples 
ncol(expr.N) # number of paired normal samples 
all(colnames(expr.C) == colnames(expr.N)) # should be TRUE
```

#### Final technical checks on counts

Check that genes (rows) are aligned between tumor and normal

```{r}
all(rownames(expr.C) == rownames(expr.N)) # must be TRUE
```

Check data types and missingness

```{r}
typeof(expr.C[1, 1])            # should be "integer" or "double" 
any(is.na(expr.C))              # should be FALSE 
any(is.nan(as.matrix(expr.C)))  # should be FALSE

typeof(expr.N[1, 1]) 
any(is.na(expr.N)) 
any(is.nan(as.matrix(expr.N)))
```

At this point:

-   expr.C = raw tumor counts, genes x N_paired patients

-   expr.N = raw normal counts, genes x N_paired patients

-   Columns in expr.C and expr.N are the SAME patients, SAME order

These are the matrices we will feed into DESeq2 for normalization.

### Normalizing data with DESeq2

Check alignment of tumor and normal matrices

```{r}
all(rownames(expr.C) == rownames(expr.N)) # Must be TRUE (same gene order)
```

Combine into full dataset: normals first, then tumors

```{r}
full.data <- cbind(expr.N, expr.C) 
full.data <- data.frame(full.data)

dim(full.data) # should be 60660 x 64 (32 normal + 32 tumor)
```

### Build metadata

```{r}
metad <- data.frame( 
    condition = factor(c( 
        rep("normal", ncol(expr.N)), 
        rep("cancer", ncol(expr.C)) 
    )) 
)
```

Row names must match full.data column names

```{r}
rownames(metad) <- colnames(full.data)
```

DESeq2 expects gene_id as a column when tidy=TRUE

```{r}
full.data <- cbind(gene_id = rownames(full.data), full.data)
```

### Build DESeq2 dataset

```{r}
dds <- DESeqDataSetFromMatrix( 
    countData = full.data, 
    colData = metad, 
    design = ~ condition, 
    tidy = TRUE 
)
```

Sanity check

```{r}
dim(counts(dds)) # should be 60660 x 64
```

### Filter low-expression genes

At least 10 counts in 90% of **all** samples (32 normal + 32 cancer = 64 → 90% = 57)

```{r}
total_samples <- ncol(expr.N) + ncol(expr.C)  # 64
threshold <- floor(0.9 * total_samples)       # 57

cat("Total samples:", total_samples, "\n")
cat("Filtering threshold (90%):", threshold, "samples\n")

keep <- rowSums(counts(dds) >= 10) >= threshold
dds <- dds[keep, ]

cat("Genes before filtering:", nrow(full.data), "\n")
cat("Genes after filtering:", nrow(dds), "\n")
cat("Genes removed:", nrow(full.data) - sum(keep), "\n")
```

### Normalize using DESeq2 size factors

```{r}
dds <- estimateSizeFactors(dds)

normalized_counts <- counts(dds, normalized = TRUE)

# No gene should be zero in all samples
sum(rowSums(normalized_counts == 0) == ncol(normalized_counts))
```

### Split normalized matrix back into normal/tumor

```{r}
filtr.expr.n <- as.data.frame( 
    normalized_counts[, 1:ncol(expr.N)] 
)

filtr.expr.c <- as.data.frame( 
    normalized_counts[, (ncol(expr.N) + 1):ncol(normalized_counts)] 
)
```

Keep original patient IDs (DESeq2 sometimes adds .1, .2)

```{r}
colnames(filtr.expr.n) <- colnames(expr.N) 
colnames(filtr.expr.c) <- colnames(expr.C)
```

### Final checks

```{r,results='hide'}
# Same genes
all(rownames(filtr.expr.c) == rownames(filtr.expr.n))

# Same patients
all(colnames(filtr.expr.c) == colnames(filtr.expr.n))

nrow(filtr.expr.c)   # number of filtered/normalized genes
ncol(filtr.expr.c)   # should be 32

sizeFactors(dds)

```
```{r}
summary(sizeFactors(dds))
```

**Output:**

-   **filtr.expr.n = normalized expression for 32 normal samples**

-   **filtr.expr.c = normalized expression for 32 tumor samples**

These matrices are what we will use for:

-   DEGs

-   Volcano Plot

-   Co-expression networks

-   Differential networks

-   PSN and SNF

## 2. Differential Expression Analysis (DEGs)

### Compute log2 Fold Change

```{r}
log2fc <- log2(rowMeans(filtr.expr.c) / rowMeans(filtr.expr.n))
names(log2fc) <- rownames(filtr.expr.c)
```

### Compute paired t-test p-values

```{r}
pval <- sapply(
  1:nrow(filtr.expr.c),
  function(i) t.test(
    as.numeric(filtr.expr.c[i, ]),
    as.numeric(filtr.expr.n[i, ]),
    paired = TRUE
  )$p.value
)
```

### FDR correction

```{r}
pval_fdr <- p.adjust(pval, method = "fdr")
```

### Build DEG table

```{r}
deg.table <- data.frame(
  gene        = rownames(filtr.expr.c),
  log2FC      = log2fc,
  pvalue      = pval,
  pvalue_fdr  = pval_fdr,
  row.names   = rownames(filtr.expr.c)
)
```

### Apply thresholds

```{r}
FDR_threshold <- 0.05
FC_threshold  <- 2

deg.genes <- subset(
  deg.table,
  abs(log2FC) >= FC_threshold & pvalue_fdr <= FDR_threshold
)

cat("Number of DEGs:", nrow(deg.genes), "\n")
```

### Volcano plot

```{r}
deg.table$color <- "NO"
deg.table$color[deg.table$log2FC >= FC_threshold & deg.table$pvalue_fdr <= FDR_threshold] <- "UP"
deg.table$color[deg.table$log2FC <= -FC_threshold & deg.table$pvalue_fdr <= FDR_threshold] <- "DOWN"
deg.table$color <- factor(deg.table$color, levels = c("DOWN", "NO", "UP"))

ggplot(deg.table, aes(x = log2FC, y = -log10(pvalue_fdr), color = color)) +
  geom_point(alpha = 0.6) +
  xlab("log2 Fold Change") +
  ylab("-log10 FDR") +
  geom_vline(xintercept = c(-FC_threshold, FC_threshold), col = "red") +
  geom_hline(yintercept = -log10(FDR_threshold), col = "red") +
  theme_minimal()


DEG_list <- rownames(deg.genes)
length(DEG_list)
```

## 3. Co-Expression Networks

### 3.1 Data Preparation

Extract DEG expression matrices and apply log transformation for correlation analysis.

```{r}
# Keep only DEGs in the normalized matrices
expr_deg_cancer <- filtr.expr.c[DEG_list, ]
expr_deg_normal <- filtr.expr.n[DEG_list, ]

# Log transform for correlation analysis
expr_deg_cancer <- log2(expr_deg_cancer + 1)
expr_deg_normal <- log2(expr_deg_normal + 1)

# Verify dimensions
cat("Expression matrix dimensions:\n")
cat(sprintf("  Cancer: %d genes × %d samples\n", nrow(expr_deg_cancer), ncol(expr_deg_cancer)))
cat(sprintf("  Normal: %d genes × %d samples\n", nrow(expr_deg_normal), ncol(expr_deg_normal)))
cat(sprintf("  Genes aligned: %s\n", all(rownames(expr_deg_cancer) == rownames(expr_deg_normal))))
```

### 3.2 Network Computation

Compute Pearson correlation matrices with FDR-adjusted p-values for both conditions.

```{r}
# Cancer correlation with FDR-adjusted p-values
cor.mat.c <- corr.test(
  t(expr_deg_cancer), 
  use = "pairwise",
  method = "pearson",
  adjust = "fdr",
  ci = FALSE
)

rho.c <- cor.mat.c$r
diag(rho.c) <- 0
qval.c <- cor.mat.c$p
qval.c[lower.tri(qval.c)] <- t(qval.c)[lower.tri(qval.c)]

# Normal correlation with FDR-adjusted p-values
cor.mat.n <- corr.test(
  t(expr_deg_normal), 
  use = "pairwise",
  method = "pearson",
  adjust = "fdr",
  ci = FALSE
)

rho.n <- cor.mat.n$r
diag(rho.n) <- 0
qval.n <- cor.mat.n$p
qval.n[lower.tri(qval.n)] <- t(qval.n)[lower.tri(qval.n)]
```

Build binary adjacency matrices using correlation and significance thresholds.

```{r}
# Define thresholds
corr_threshold_c <- 0.7   # Cancer correlation threshold
corr_threshold_n <- 0.8   # Normal correlation threshold (more stringent)
pval_threshold  <- 0.05  # FDR-adjusted p-value threshold

# Build binary adjacency matrices
adj_mat_c <- ((abs(rho.c) >= corr_threshold_c) & (qval.c <= pval_threshold)) * 1
adj_mat_n <- ((abs(rho.n) >= corr_threshold_n) & (qval.n <= pval_threshold)) * 1
```

```{r}
# Detailed network statistics
cat("\n=== CANCER NETWORK STATISTICS ===\n")
cat(sprintf("Total possible edges: %d\n", nrow(adj_mat_c) * (nrow(adj_mat_c) - 1) / 2))
cat(sprintf("Significant edges: %d\n", sum(adj_mat_c != 0) / 2))
cat(sprintf("Network density: %.4f\n", sum(adj_mat_c != 0) / (nrow(adj_mat_c) * (nrow(adj_mat_c) - 1))))
cat(sprintf("  - Positive correlations: %d\n", sum((adj_mat_c == 1) & (rho.c > 0)) / 2))
cat(sprintf("  - Negative correlations: %d\n", sum((adj_mat_c == 1) & (rho.c < 0)) / 2))

cat("\n=== NORMAL NETWORK STATISTICS ===\n")
cat(sprintf("Total possible edges: %d\n", nrow(adj_mat_n) * (nrow(adj_mat_n) - 1) / 2))
cat(sprintf("Significant edges: %d\n", sum(adj_mat_n != 0) / 2))
cat(sprintf("Network density: %.4f\n", sum(adj_mat_n != 0) / (nrow(adj_mat_n) * (nrow(adj_mat_n) - 1))))
cat(sprintf("  - Positive correlations: %d\n", sum((adj_mat_n == 1) & (rho.n > 0)) / 2))
cat(sprintf("  - Negative correlations: %d\n", sum((adj_mat_n == 1) & (rho.n < 0)) / 2))
```


### 3.3 Degree Analysis and Scale-Free Properties

Compute degree centrality for each network.

```{r}
# Compute degree for each network
degree_c <- colSums(adj_mat_c != 0)
names(degree_c) <- rownames(adj_mat_c)
degree_c <- sort(degree_c, decreasing = TRUE)

degree_n <- colSums(adj_mat_n != 0)
names(degree_n) <- rownames(adj_mat_n)
degree_n <- sort(degree_n, decreasing = TRUE)

# Summary statistics
cat("=== DEGREE DISTRIBUTION SUMMARY ===\n\n")
cat("Cancer Network:\n")
cat(sprintf("  Max degree: %d\n", max(degree_c)))
cat(sprintf("  Mean degree: %. 2f\n", mean(degree_c)))
cat(sprintf("  Median degree: %.1f\n", median(degree_c)))
cat(sprintf("  Nodes with degree > 0: %d (%.1f%%)\n", 
            sum(degree_c > 0), 100 * sum(degree_c > 0) / length(degree_c)))

cat("\nNormal Network:\n")
cat(sprintf("  Max degree: %d\n", max(degree_n)))
cat(sprintf("  Mean degree: %.2f\n", mean(degree_n)))
cat(sprintf("  Median degree: %.1f\n", median(degree_n)))
cat(sprintf("  Nodes with degree > 0: %d (%. 1f%%)\n", 
            sum(degree_n > 0), 100 * sum(degree_n > 0) / length(degree_n)))
```

#### Scale-Free Network Analysis

A scale-free network follows a power-law degree distribution. We check this by plotting log-log degree distributions.

```{r fig.width=10, fig.height=4}
par(mfrow = c(1, 2))

# Cancer Network
hist(degree_c, breaks = 50, main = "Cancer Network Degree Distribution",
     xlab = "Degree", col = "lightcoral", freq = FALSE)

# Normal Network
hist(degree_n, breaks = 50, main = "Normal Network Degree Distribution",
     xlab = "Degree", col = "lightgreen", freq = FALSE)

par(mfrow = c(1, 1))
```

```{r fig.width=10, fig.height=4}

# Function to estimate gamma using zeta free log-likelihood
estimate_gamma_zeta <- function(deg_freq, kmax = 100000) {
  # Build vector of observations from frequency table
  k_values <- as.numeric(names(deg_freq))
  k_counts <- as.numeric(deg_freq)
  
  # Expand into full sample vector
  k <- rep(k_values, k_counts)
  
  # Minimum degree
  k_min <- min(k)
  
  # Free zeta log-likelihood function
  loglik_zeta_free <- function(gamma, k, k_min, kmax) {
    if (gamma <= 1) return(-Inf)
    
    N <- length(k)
    M_prime <- sum(log(k))
    
    # Normalization constant (truncated zeta)
    Z <- sum(1 / (k_min:kmax)^gamma)
    
    if (!is.finite(Z) || Z <= 0) return(-Inf)
    
    # Log-likelihood
    -gamma * M_prime - N * log(Z)
  }
  
  # MLE fit
  result <- tryCatch({
    fit <- optim(
      par = 2.0,  # Initial gamma
      fn = function(gamma) -loglik_zeta_free(gamma, k, k_min, kmax),
      method = "Brent",
      lower = 1.01,
      upper = 10
    )
    
    gamma_hat <- fit$par
    ll <- -fit$value
    
    list(gamma = gamma_hat, loglik = ll, success = TRUE)
  }, error = function(e) {
    list(gamma = NA, loglik = NA, success = FALSE)
  })
  
  return(result)
}

par(mfrow = c(1, 2))

# Cancer: Log-Log plot
deg_freq_c <- table(degree_c[degree_c > 0])
if (length(deg_freq_c) > 1) {
  # Estimate gamma using zeta MLE
  zeta_result_c <- estimate_gamma_zeta(deg_freq_c)
  gamma_c <- zeta_result_c$gamma
  
  # Plot
  plot(log10(as.numeric(names(deg_freq_c))), log10(as.numeric(deg_freq_c)), 
       main = "Cancer: Log-Log Degree Distribution", 
       xlab = "log10(Degree)", ylab = "log10(Frequency)", 
       pch = 16, col = "lightcoral", cex = 1.2)
  
  # Fit line for visualization (using estimated gamma)
  x_vals <- log10(as.numeric(names(deg_freq_c)))
  y_vals <- log10(as.numeric(deg_freq_c))

  fit_c <- lm(y_vals ~ x_vals)
  
  abline(fit_c, col = "darkred", lwd = 2, lty = 2)
  
  legend("topright", 
         legend = paste("γ (MLE) =", round(gamma_c, 2)),
         bty = "n", cex = 0.9)
}

# Normal: Log-Log plot
deg_freq_n <- table(degree_n[degree_n > 0])
if (length(deg_freq_n) > 1) {
  # Estimate gamma using zeta MLE
  zeta_result_n <- estimate_gamma_zeta(deg_freq_n)
  gamma_n <- zeta_result_n$gamma
  ll_n <- zeta_result_n$loglik
  
  # Plot
  plot(log10(as.numeric(names(deg_freq_n))), log10(as.numeric(deg_freq_n)), 
       main = "Normal: Log-Log Degree Distribution", 
       xlab = "log10(Degree)", ylab = "log10(Frequency)", 
       pch = 16, col = "lightgreen", cex = 1.2)
  
  # Fit line for visualization
  x_vals <- log10(as.numeric(names(deg_freq_n)))
  y_vals <- log10(as.numeric(deg_freq_n))
  
  # Linear regression for R² calculation
  fit_n <- lm(y_vals ~ x_vals)
  
  abline(fit_n, col = "darkgreen", lwd = 2, lty = 2)
  
  legend("topright", 
         legend = paste("γ (MLE) =", round(gamma_n, 2)),
         bty = "n", cex = 0.9)
}

par(mfrow = c(1, 1))
```


### 3.4 Hub Identification and Comparison

Identify hubs as the top 5% of nodes with highest degree values.

```{r}
# Define hub thresholds (top 5% of connected nodes)
hub_threshold_c <- quantile(degree_c[degree_c > 0], 0.95)
hub_threshold_n <- quantile(degree_n[degree_n > 0], 0.95)

# Identify hubs
hubs_c <- degree_c[degree_c >= hub_threshold_c]
hubs_n <- degree_n[degree_n >= hub_threshold_n]

cat("=== HUB IDENTIFICATION ===\n")
cat(sprintf("Cancer Network:\n"))
cat(sprintf("  Hub threshold (95th percentile): degree ≥ %d\n", hub_threshold_c))
cat(sprintf("  Number of hubs: %d\n", length(hubs_c)))

cat(sprintf("\nNormal Network:\n"))
cat(sprintf("  Hub threshold (95th percentile): degree ≥ %d\n", hub_threshold_n))
cat(sprintf("  Number of hubs: %d\n", length(hubs_n)))
```

#### Hub Comparison Between Conditions

```{r}
# Compare hub sets
common_hubs <- intersect(names(hubs_c), names(hubs_n))
selective_hubs_c <- setdiff(names(hubs_c), names(hubs_n))
selective_hubs_n <- setdiff(names(hubs_n), names(hubs_c))

cat("=== HUB COMPARISON: CANCER vs NORMAL ===\n")
cat(sprintf("Common hubs (present in both): %d\n", length(common_hubs)))
cat(sprintf("Cancer-selective hubs: %d\n", length(selective_hubs_c)))
cat(sprintf("Normal-selective hubs: %d\n", length(selective_hubs_n)))
```


### 3.5 Gene Symbol Mapping

Map Ensembl IDs to gene symbols for biological interpretation.

```{r}
# Create gene mapping
gene_mapping <- genes.info[, c("gene_id", "gene_name")]
rownames(gene_mapping) <- gene_mapping$gene_id

get_gene_symbol <- function(ensembl_id, mapping = gene_mapping) {
  if (ensembl_id %in% rownames(mapping)) {
    symbol <- mapping[ensembl_id, "gene_name"]
    if (! is.na(symbol) && symbol != "") return(symbol)
  }
  return(ensembl_id)
}
```

#### Top 3 Hubs in Each Network

```{r}
# Top 3 Cancer Hubs
top3_cancer <- head(degree_c[degree_c > 0], 3)
top3_cancer_symbols <- sapply(names(top3_cancer), get_gene_symbol)

cat("=== TOP 3 HUBS: CANCER NETWORK ===\n\n")
for (i in 1:3) {
  cat(sprintf("%d. %s (%s) - Degree: %d\n", 
              i, top3_cancer_symbols[i], names(top3_cancer)[i], top3_cancer[i]))
}

# Top 3 Normal Hubs
top3_normal <- head(degree_n[degree_n > 0], 3)
top3_normal_symbols <- sapply(names(top3_normal), get_gene_symbol)

cat("\n=== TOP 3 HUBS: NORMAL NETWORK ===\n\n")
for (i in 1:3) {
  cat(sprintf("%d. %s (%s) - Degree: %d\n", 
              i, top3_normal_symbols[i], names(top3_normal)[i], top3_normal[i]))
}
```


### 3.6 Alternative Centrality Analysis (Betweenness)

Compare degree-based hubs with betweenness centrality to identify genes that serve as bridges.

```{r}
# Convert to igraph objects
graph_cancer <- graph_from_adjacency_matrix(adj_mat_c, mode = "undirected", diag = FALSE)
graph_normal <- graph_from_adjacency_matrix(adj_mat_n, mode = "undirected", diag = FALSE)

# Compute betweenness centrality
betweenness_c <- betweenness(graph_cancer, directed = FALSE, normalized = TRUE)
betweenness_n <- betweenness(graph_normal, directed = FALSE, normalized = TRUE)

names(betweenness_c) <- V(graph_cancer)$name
names(betweenness_n) <- V(graph_normal)$name

betweenness_c <- sort(betweenness_c, decreasing = TRUE)
betweenness_n <- sort(betweenness_n, decreasing = TRUE)
```

```{r}
# Identify top 5% by betweenness
bc_threshold_c <- quantile(betweenness_c[betweenness_c > 0], 0.95)
bc_threshold_n <- quantile(betweenness_n[betweenness_n > 0], 0.95)

top_bc_c <- betweenness_c[betweenness_c >= bc_threshold_c]
top_bc_n <- betweenness_n[betweenness_n >= bc_threshold_n]

# Compare with degree-based hubs
overlap_c <- intersect(names(top_bc_c), names(hubs_c))
overlap_n <- intersect(names(top_bc_n), names(hubs_n))

cat("=== DEGREE vs BETWEENNESS CENTRALITY COMPARISON ===\n")
cat("Cancer Network:\n")
cat(sprintf("  Degree hubs: %d | Betweenness hubs: %d | Overlap: %d (%.1f%%)\n",
            length(hubs_c), length(top_bc_c), length(overlap_c),
            100 * length(overlap_c) / length(union(names(hubs_c), names(top_bc_c)))))

cat("\nNormal Network:\n")
cat(sprintf("  Degree hubs: %d | Betweenness hubs: %d | Overlap: %d (%.1f%%)\n",
            length(hubs_n), length(top_bc_n), length(overlap_n),
            100 * length(overlap_n) / length(union(names(hubs_n), names(top_bc_n)))))
```

```{r fig.width=10, fig.height=5}
# Visualization
library(dplyr)

centrality_cancer_df <- data.frame(
  Gene = names(degree_c),
  Degree = as.numeric(degree_c),
  Betweenness = betweenness_c[names(degree_c)]
) %>%
  mutate(Hub_Type = case_when(
    Gene %in% overlap_c ~ "Both",
    Gene %in% names(hubs_c) ~ "Degree Only",
    Gene %in% names(top_bc_c) ~ "Betweenness Only",
    TRUE ~ "Non-Hub"
  ))

centrality_normal_df <- data.frame(
  Gene = names(degree_n),
  Degree = as.numeric(degree_n),
  Betweenness = betweenness_n[names(degree_n)]
) %>%
  mutate(Hub_Type = case_when(
    Gene %in% overlap_n ~ "Both",
    Gene %in% names(hubs_n) ~ "Degree Only",
    Gene %in% names(top_bc_n) ~ "Betweenness Only",
    TRUE ~ "Non-Hub"
  ))

p1 <- ggplot(centrality_cancer_df, aes(x = Degree, y = Betweenness, color = Hub_Type)) +
  geom_point(alpha = 0.6, size = 2) +
  scale_color_manual(values = c("Both" = "purple", "Degree Only" = "red", 
                                "Betweenness Only" = "blue", "Non-Hub" = "gray70")) +
  labs(title = "Cancer Network", x = "Degree", y = "Betweenness") +
  theme_minimal() + theme(legend.position = "bottom")

p2 <- ggplot(centrality_normal_df, aes(x = Degree, y = Betweenness, color = Hub_Type)) +
  geom_point(alpha = 0.6, size = 2) +
  scale_color_manual(values = c("Both" = "purple", "Degree Only" = "red", 
                                "Betweenness Only" = "blue", "Non-Hub" = "gray70")) +
  labs(title = "Normal Network", x = "Degree", y = "Betweenness") +
  theme_minimal() + theme(legend.position = "bottom")

gridExtra::grid.arrange(p1, p2, ncol = 2, top = "Degree vs Betweenness Centrality")
```

```{r}
# Correlation between centrality measures
cor_c <- cor(centrality_cancer_df$Degree, centrality_cancer_df$Betweenness, 
             method = "spearman", use = "complete.obs")
cor_n <- cor(centrality_normal_df$Degree, centrality_normal_df$Betweenness, 
             method = "spearman", use = "complete.obs")

cat("=== CENTRALITY CORRELATION ===\n")
cat(sprintf("Cancer Network (Spearman): %.3f\n", cor_c))
cat(sprintf("Normal Network (Spearman): %.3f\n", cor_n))
```


## 4. Differential Co-Expression Network

### 4.1 Network Computation

Compute differential co-expression using Fisher's Z-transform to identify edges with significantly changed correlations.

```{r}
# Sample sizes
n_c <- ncol(expr_deg_cancer)
n_n <- ncol(expr_deg_normal)

# Fisher's Z-transform
fisher_z <- function(r) {
  0.5 * log((1 + r) / (1 - r))
}

z_c <- fisher_z(rho.c)
z_n <- fisher_z(rho.n)

# Z-score for difference
se <- sqrt(1/(n_c - 3) + 1/(n_n - 3))
z_diff <- (z_c - z_n) / se

# Binary adjacency matrix
z_threshold <- 5  # |Z| >= 5 for significant differential co-expression
adj_mat_diff <- (abs(z_diff) >= z_threshold) * 1
diag(adj_mat_diff) <- 0

cat("=== DIFFERENTIAL NETWORK COMPUTATION ===\n\n")
cat(sprintf("Z-score threshold: |Z| ≥ %d\n", z_threshold))
cat(sprintf("Total possible edges: %d\n", nrow(adj_mat_diff) * (nrow(adj_mat_diff) - 1) / 2))
cat(sprintf("Differential edges: %d\n", sum(adj_mat_diff) / 2))
cat(sprintf("Network density: %.4f\n", sum(adj_mat_diff) / (nrow(adj_mat_diff) * (nrow(adj_mat_diff) - 1))))
```

### 4.2 Degree Analysis and Scale-Free Properties

```{r}
# Compute differential degree
degree_diff <- colSums(adj_mat_diff != 0)
names(degree_diff) <- rownames(adj_mat_diff)
degree_diff <- sort(degree_diff, decreasing = TRUE)

cat("=== DIFFERENTIAL NETWORK DEGREE SUMMARY ===\n")
cat(sprintf("Max degree: %d\n", max(degree_diff)))
cat(sprintf("Mean degree: %.2f\n", mean(degree_diff)))
cat(sprintf("Nodes with degree > 0: %d (%.1f%%)\n", 
            sum(degree_diff > 0), 100 * sum(degree_diff > 0) / length(degree_diff)))
```

```{r fig.width=10, fig.height=4}
par(mfrow = c(1, 2))

# Histogram
hist(degree_diff, breaks = 50, main = "Differential Network Degree Distribution",
     xlab = "Degree", col = "plum", freq = FALSE)

# Log-log plot
deg_freq_diff <- table(degree_diff[degree_diff > 0])
if (length(deg_freq_diff) > 1) {
  # Estimate gamma using zeta MLE (function defined earlier)
  zeta_result_diff <- estimate_gamma_zeta(deg_freq_diff)
  gamma_diff <- zeta_result_diff$gamma
  
  # Plot
  plot(log10(as.numeric(names(deg_freq_diff))), log10(as.numeric(deg_freq_diff)), 
       main = "Differential: Log-Log Degree Distribution", 
       xlab = "log10(Degree)", ylab = "log10(Frequency)", 
       pch = 16, col = "plum", cex = 1.2)
  
  # Fit line for visualization
  x_vals <- log10(as.numeric(names(deg_freq_diff)))
  y_vals <- log10(as.numeric(deg_freq_diff))
  
  # Linear regression for R² calculation
  fit_diff <- lm(y_vals ~ x_vals)
  
  abline(fit_diff, col = "purple", lwd = 2, lty = 2)
  
  legend("topright", 
         legend = c(paste("γ (MLE) =", round(gamma_diff, 2))), 
         bty = "n", cex = 0.9)
}

par(mfrow = c(1, 1))

```

### 4.3 Hub Identification and Comparison with Co-expression Networks

```{r}
# Identify differential hubs (top 5%)
hub_threshold_diff <- quantile(degree_diff[degree_diff > 0], 0.95)
hubs_diff <- degree_diff[degree_diff >= hub_threshold_diff]

cat("=== DIFFERENTIAL HUB IDENTIFICATION ===\n")
cat(sprintf("Hub threshold (95th percentile): degree ≥ %.2f \n", hub_threshold_diff))
cat(sprintf("Number of differential hubs: %d \n", length(hubs_diff)))
```

#### Compare with Task 3 Hubs

```{r}
# Compare differential hubs with cancer and normal hubs
common_diff_c <- intersect(names(hubs_diff), names(hubs_c))
common_diff_n <- intersect(names(hubs_diff), names(hubs_n))
selective_diff <- setdiff(names(hubs_diff), union(names(hubs_c), names(hubs_n)))

cat("=== COMPARISON: DIFFERENTIAL vs CO-EXPRESSION HUBS ===\n")
cat(sprintf("Differential hubs also in Cancer network: %d\n", length(common_diff_c)))
cat(sprintf("Differential hubs also in Normal network: %d\n", length(common_diff_n)))
cat(sprintf("Differential hubs unique (not hubs in either): %d\n", length(selective_diff)))
```


### 4.4 Top 3 Differential Hubs Analysis

```{r}
# Top 3 differential hubs
top3_diff <- head(degree_diff[degree_diff > 0], 3)
top3_diff_symbols <- sapply(names(top3_diff), get_gene_symbol)

cat("=== TOP 3 HUBS: DIFFERENTIAL NETWORK ===\n")
for (i in 1:3) {
  cat(sprintf("%d. %s (%s) - Differential Degree: %d\n", 
              i, top3_diff_symbols[i], names(top3_diff)[i], top3_diff[i]))
}
```

```{r}
cat("=== DETAILED CONNECTIVITY ANALYSIS ===\n")

top_diff_genes <- names(top3_diff)

for (i in 1:3) {
  gene <- top_diff_genes[i]
  symbol <- get_gene_symbol(gene)
  
  # Find neighbors in each network
  neighbors_n <- colnames(adj_mat_n)[adj_mat_n[gene, ] != 0]
  neighbors_c <- colnames(adj_mat_c)[adj_mat_c[gene, ] != 0]
  neighbors_diff <- colnames(adj_mat_diff)[adj_mat_diff[gene, ] != 0]
  
  # Calculate overlaps
  preserved <- intersect(neighbors_n, neighbors_c)
  lost <- setdiff(neighbors_n, neighbors_c)
  gained <- setdiff(neighbors_c, neighbors_n)
  
  # Z-score direction
  z_vals <- z_diff[gene, neighbors_diff]
  n_pos_z <- sum(z_vals > 0, na.rm = TRUE)
  n_neg_z <- sum(z_vals < 0, na.rm = TRUE)
  
  cat(sprintf("--- %d. %s ---\n", i, symbol))
  cat(sprintf("  Normal Degree: %d → Cancer Degree: %d (Change: %+d)\n", 
              degree_n[gene], degree_c[gene], degree_c[gene] - degree_n[gene]))
  cat(sprintf("  Differential Degree: %d\n", degree_diff[gene]))
  cat(sprintf("  Connections preserved: %d | Lost: %d | Gained: %d\n", 
              length(preserved), length(lost), length(gained)))
  cat(sprintf("  Edges with ↑ correlation in cancer: %d | ↓ correlation: %d\n", 
              n_pos_z, n_neg_z))
}
```

```{r fig.width=8, fig.height=5}
# Visualization
plot_data <- data.frame(
  Gene = rep(comparison_table$Gene_Symbol, 2),
  Condition = rep(c("Normal", "Cancer"), each = 3),
  Degree = c(comparison_table$Degree_Normal, comparison_table$Degree_Cancer)
)
plot_data$Gene <- factor(plot_data$Gene, levels = comparison_table$Gene_Symbol)
plot_data$Condition <- factor(plot_data$Condition, levels = c("Normal", "Cancer"))

ggplot(plot_data, aes(x = Gene, y = Degree, fill = Condition)) +
  geom_bar(stat = "identity", position = "dodge", alpha = 0.8, width = 0.7) +
  geom_text(aes(label = Degree), position = position_dodge(width = 0.7), vjust = -0.5, size = 3.5) +
  scale_fill_manual(values = c("Normal" = "#4DAF4A", "Cancer" = "#E41A1C")) +
  labs(title = "Top 3 Differential Hubs: Degree Comparison",
       subtitle = "How connectivity changes from Normal to Cancer",
       x = "Gene Symbol", y = "Degree") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "top",
        plot.title = element_text(hjust = 0.5, face = "bold"))
```

### 4.5 Hub Transition Analysis

```{r}
# Full comparison for all differential hubs
all_diff_hub_genes <- names(hubs_diff)

full_comparison <- data.frame(
  Gene_Symbol = sapply(all_diff_hub_genes, get_gene_symbol),
  Ensembl_ID = all_diff_hub_genes,
  Degree_Normal = degree_n[all_diff_hub_genes],
  Degree_Cancer = degree_c[all_diff_hub_genes],
  Degree_Differential = degree_diff[all_diff_hub_genes],
  Is_Hub_Normal = all_diff_hub_genes %in% names(hubs_n),
  Is_Hub_Cancer = all_diff_hub_genes %in% names(hubs_c),
  stringsAsFactors = FALSE
)

full_comparison$Hub_Transition <- case_when(
  full_comparison$Is_Hub_Normal & full_comparison$Is_Hub_Cancer ~ "Hub in Both",
  full_comparison$Is_Hub_Normal & !full_comparison$Is_Hub_Cancer ~ "Lost Hub Status",
  !full_comparison$Is_Hub_Normal & full_comparison$Is_Hub_Cancer ~ "Gained Hub Status",
  TRUE ~ "Differential Hub Only"
)

full_comparison <- full_comparison[order(-full_comparison$Degree_Differential), ]

# Summary
transition_summary <- table(full_comparison$Hub_Transition)
cat("=== HUB TRANSITION SUMMARY ===\n")
print(transition_summary)
```


### 4.6 Signed Differential Network Analysis

Distinguish between edges where correlations increased vs decreased in cancer.

```{r}
# Positive subnetwork (correlations INCREASED in cancer)
adj_mat_diff_positive <- (z_diff >= z_threshold) * 1
diag(adj_mat_diff_positive) <- 0

# Negative subnetwork (correlations DECREASED in cancer)
adj_mat_diff_negative <- (z_diff <= -z_threshold) * 1
diag(adj_mat_diff_negative) <- 0

cat("=== SIGNED DIFFERENTIAL NETWORK STATISTICS ===\n")
cat(sprintf("Positive edges (correlation ↑ in cancer): %d\n", sum(adj_mat_diff_positive) / 2))
cat(sprintf("Negative edges (correlation ↓ in cancer): %d\n", sum(adj_mat_diff_negative) / 2))
cat(sprintf("Ratio (Positive/Negative): %.2f\n", 
            sum(adj_mat_diff_positive) / max(sum(adj_mat_diff_negative), 1)))
```

```{r}
# Compute signed degrees
degree_positive <- colSums(adj_mat_diff_positive)
names(degree_positive) <- rownames(adj_mat_diff_positive)
degree_positive <- sort(degree_positive, decreasing = TRUE)

degree_negative <- colSums(adj_mat_diff_negative)
names(degree_negative) <- rownames(adj_mat_diff_negative)
degree_negative <- sort(degree_negative, decreasing = TRUE)

# Identify signed hubs
pos_threshold <- quantile(degree_positive[degree_positive > 0], 0.95)
neg_threshold <- quantile(degree_negative[degree_negative > 0], 0.95)

hubs_positive <- degree_positive[degree_positive >= pos_threshold & degree_positive > 0]
hubs_negative <- degree_negative[degree_negative >= neg_threshold & degree_negative > 0]

cat("=== SIGNED HUBS ===\n")
cat(sprintf("Positive hubs (correlations ↑ in cancer): %d\n", length(hubs_positive)))
cat(sprintf("Negative hubs (correlations ↓ in cancer): %d\n", length(hubs_negative)))
```

#### Top 3 Positive and Negative Hubs

```{r}
# Top positive hubs
top3_pos <- head(hubs_positive, 3)
top3_pos_symbols <- sapply(names(top3_pos), get_gene_symbol)

cat("=== TOP 3 POSITIVE HUBS ===\n")
cat("(Genes whose correlations INCREASED in cancer)\n")
for (i in seq_along(top3_pos)) {
  cat(sprintf("%d.  %s - Positive Degree: %d\n", i, top3_pos_symbols[i], top3_pos[i]))
}

# Top negative hubs
top3_neg <- head(hubs_negative, 3)
top3_neg_symbols <- sapply(names(top3_neg), get_gene_symbol)

cat("\n=== TOP 3 NEGATIVE HUBS ===\n")
cat("(Genes whose correlations DECREASED in cancer)\n")
for (i in seq_along(top3_neg)) {
  cat(sprintf("%d. %s - Negative Degree: %d\n", i, top3_neg_symbols[i], top3_neg[i]))
}
```

```{r fig.width=9, fig.height=6}
# Visualization: Positive vs Negative degree
all_genes_signed <- data.frame(
  Gene = names(degree_positive),
  Positive_Degree = as.numeric(degree_positive),
  Negative_Degree = as.numeric(degree_negative[names(degree_positive)])
) %>%
  mutate(Type = case_when(
    Gene %in% names(hubs_positive) & Gene %in% names(hubs_negative) ~ "Both Hubs",
    Gene %in% names(hubs_positive) ~ "Positive Hub",
    Gene %in% names(hubs_negative) ~ "Negative Hub",
    TRUE ~ "Non-Hub"
  ))

ggplot(all_genes_signed, aes(x = Positive_Degree, y = Negative_Degree, color = Type)) +
  geom_point(alpha = 0.6, size = 2) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray50") +
  scale_color_manual(values = c("Both Hubs" = "purple", "Positive Hub" = "#E41A1C", 
                                "Negative Hub" = "#377EB8", "Non-Hub" = "gray70")) +
  labs(title = "Signed Differential Network: Positive vs Negative Degree",
       subtitle = "Above diagonal: more connections decreased | Below: more increased",
       x = "Positive Degree (correlations ↑ in cancer)",
       y = "Negative Degree (correlations ↓ in cancer)") +
  theme_minimal() +
  theme(legend.position = "right", plot.title = element_text(hjust = 0.5, face = "bold"))
```

### 4.7 Subnetwork Visualization

#### Top Differential Hub Subnetwork

```{r fig.width=10, fig.height=8}
top_gene <- names(degree_diff)[1]
top_gene_symbol <- get_gene_symbol(top_gene)

# Find neighbors
neighbors <- which(adj_mat_diff[top_gene, ] != 0)
neighbor_names <- colnames(adj_mat_diff)[neighbors]

# Subset network
subnet_nodes <- unique(c(top_gene, neighbor_names))
subnet_adj <- adj_mat_diff[subnet_nodes, subnet_nodes]

# Create network object
net_subnet <- network(subnet_adj, matrix.type = "adjacency", 
                      ignore.eval = FALSE, names.eval = "weights", directed = FALSE)

# Set attributes
net_subnet %v% "type" <- ifelse(network.vertex.names(net_subnet) == top_gene, "hub", "neighbor")
net_subnet %v% "color" <- ifelse(net_subnet %v% "type" == "hub", "red", "steelblue")

# Labels
node_labels <- sapply(network.vertex.names(net_subnet), get_gene_symbol)

ggnet2(net_subnet, color = "color", alpha = 0.8, size = 4,
       edge.color = "gray60", edge.alpha = 0.5, edge.size = 0.3,
       label = node_labels, label.size = 2.5, label.color = "black") +
  ggtitle(paste("Subnetwork of", top_gene_symbol, 
                "(Top Differential Hub, Degree:", degree_diff[top_gene], ")")) +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))
```



## 5. Patient Similarity Network (PSN)

### a. Computation of the PSN

#### Data preparation

```{r}
# we use expr_deg_cancer because it contains normalized and log-transoformed data
# dds or rna.expr.data.C are raw counts so if used well expressed genes would end up dominating the calculation
target_data <- as.matrix(expr_deg_cancer)
```

Check dimension

```{r}
print(dim(target_data)) # we expect N_DEGs x 32 patients
```

#### Calculation of the similarity matrix

Calculate Pearson correlation between patients (columns)

```{r}
patient_sim_matrix <- cor(target_data, method = "pearson")
```

#### Clean-up of the matrix

Set the diagonal to 0 to remove self-loops

```{r}
diag(patient_sim_matrix) <- 0
dim(patient_sim_matrix)
```

#### Manage negative correlations

We're only interested in positive correlations

```{r}
patient_sim_matrix[patient_sim_matrix<0] <- 0
```

#### Create the network object

```{r}
psn_graph <- graph_from_adjacency_matrix(
  patient_sim_matrix,
  mode = "undirected",
  weighted = TRUE,
  diag = FALSE
)
```

#### Check of the graph

```{r}
cat("# of nodes (patients):", vcount(psn_graph), "\n")
cat("# of edges:", ecount(psn_graph), "\n")
```

Plot of the PSN

```{r}
# creates a network object because ggnet2 needs it for plotting
# otherwise by passing an igraph object such as psn_graph, it would need an additional library
net_obj <- network(patient_sim_matrix, 
                   matrix.type = "adjacency", 
                   ignore.eval = FALSE,    # keeps weights
                   names.eval = "weights", 
                   directed = FALSE)

ggnet2(net_obj,
       size = 6,
       color = "orange",
       label = TRUE,
       label.size = 3,
       label.color = "black",
       edge.size = "weights",      
       edge.color = "gray80"
) +
  ggtitle("Patient Similarity Network")
```

### b. Community detection

#### Applying the Louvain Algorithm

```{r}
louvain_cl <- cluster_louvain(psn_graph)
```

#### Create the result dataframe

```{r}
comm_res <- data.frame(
  patient = names(membership(louvain_cl)),
  community = as.character(membership(louvain_cl)),
  stringsAsFactors = FALSE
)
```

#### Network Preparation for Plotting

Filter the matrix by applying a threshold to keep only the strongest conenctions

```{r}
l_comp <- patient_sim_matrix

# Apply a threshold
threshold_plot <- 0.7 
l_comp[abs(l_comp) < threshold_plot] <- 0
diag(l_comp) <- 0
```

```{r}
net_final <- network(l_comp, 
                     matrix.type = "adjacency", 
                     ignore.eval = FALSE, 
                     names.eval = "weights", 
                     directed = FALSE)
```

#### Assigning attributes

```{r}
net_names <- network.vertex.names(net_final)
net_final %v% "community" <- comm_res$community[match(net_names, comm_res$patient)]
network::set.edge.attribute(net_final, "edgecolor", "gray90")
```

#### Check how many communities we have

```{r}
n_communities <- length(unique(net_final %v% "community"))
cat("Number of communities found:", n_communities, "\n")
```

#### Plot

```{r}
# Create colour palette (Dynamic based on number of communities)
set.seed(13)
# Sample distinct colors
pal <- sample(colors(distinct = TRUE), n_communities)
names(pal) <- sort(unique(net_final %v% "community"))

ggnet2(net_final, 
       color = "community", 
       palette = pal, 
       alpha = 0.9, 
       size = 6, 
       label = TRUE,               # patient IDs
       label.size = 3,
       edge.color = "edgecolor", 
       edge.alpha = 0.8, 
       edge.size = 0.3) +
  guides(size = "none") +
  ggtitle("PSN Community Structure (Louvain)")
```

## 5. PSN USING NORMAL GENE EXPRESSION

Data preparation

```{r}
target_data_normal <- as.matrix(expr_deg_normal)   # DEGs × Patients (normal samples)

cat("Dimensioni matrice NORMAL (DEGs x Patients):\n")
print(dim(target_data_normal))
```

Similarity matrix calculation

```{r}
psn_normal_matrix <- cor(target_data_normal, method = "pearson")

# Remove auto-correlations
diag(psn_normal_matrix) <- 0

# Consider only positive correlations
psn_normal_matrix[psn_normal_matrix < 0] <- 0
```

Create the network object

```{r}
psn_graph_normal <- graph_from_adjacency_matrix(
  psn_normal_matrix,
  mode = "undirected",
  weighted = TRUE,
  diag = FALSE
)
cat("NORMAL PSN — Nodes:", vcount(psn_graph_normal),
    "Edges:", ecount(psn_graph_normal), "\n")
```

Community detection with Louvain

```{r}

louvain_normal <- cluster_louvain(psn_graph_normal)

comm_res_normal <- data.frame(
  patient = names(membership(louvain_normal)),
  community_normal = as.character(membership(louvain_normal)),
  stringsAsFactors = FALSE
)

cat("Number of communities (NORMAL):",
    length(unique(comm_res_normal$community_normal)), "\n")
```

Preparation for plotting

```{r}

plot_threshold <- 0.7
psn_plot_mat <- psn_normal_matrix
psn_plot_mat[psn_plot_mat < plot_threshold] <- 0


net_normal <- network(psn_plot_mat,
                      matrix.type = "adjacency",
                      ignore.eval = FALSE,
                      names.eval = "weights",
                      directed = FALSE)

net_names_norm <- network.vertex.names(net_normal)
net_normal %v% "community" <- comm_res_normal$community_normal[
  match(net_names_norm, comm_res_normal$patient)
]
```

Plot Normal PSN

```{r}
set.seed(77)
n_comm_norm <- length(unique(net_normal %v% "community"))
palette_norm <- sample(colors(distinct = TRUE), n_comm_norm)
names(palette_norm) <- sort(unique(net_normal %v% "community"))

ggnet2(net_normal,
       color = "community",
       palette = palette_norm,
       size = 6,
       label = TRUE,
       label.size = 3,
       edge.color = "gray85",
       edge.alpha = 0.8) +
  ggtitle("Patient Similarity Network — NORMAL (DEGs)")
```

Comparison between Tumor and Normal PSNs

```{r}
comparison_psn <- merge(comm_res, comm_res_normal, by = "patient")
colnames(comparison_psn) <- c("Patient", "Cancer_Community", "Normal_Community")
conf_mat_norm <- table(
  Cancer = comparison_psn$Cancer_Community,
  Normal = comparison_psn$Normal_Community
)
print("Confusion Matrix (Cancer vs Normal PSN):")
print(conf_mat_norm)
```

Heatmap of the confusion matrix

```{r}
melt_norm <- as.data.frame(as.table(conf_mat_norm))
colnames(melt_norm) <- c("Cancer_Group", "Normal_Group", "Count")

ggplot(melt_norm, aes(x = Normal_Group, y = Cancer_Group, fill = Count)) +
  geom_tile(color = "white") +
  geom_text(aes(label = Count), color = "black", size = 5) +
  scale_fill_gradient(low = "white", high = "steelblue") +
  labs(title = "Comparison: PSN Cancer vs PSN Normal",
       x = "Normal communities",
       y = "Cancer communities") +
  theme_minimal() +
  theme(panel.grid.major = element_blank())
```

## 5. Patient Similarity Network (PSN)

### c. Similarity Network Fusion

#### Download & Processing of Mutation Data

We download the Simple Nucleotide Variation data for TCGA-KIRP and convert it into a binary mutation matrix.

```{r message=FALSE}
query_mut <- TCGAbiolinks::GDCquery(
  project = proj, 
  data.category = "Simple Nucleotide Variation", 
  data.type = "Masked Somatic Mutation",
  workflow.type = "Aliquot Ensemble Somatic Variant Merging and Masking" # current standard 
)
```

Actual download **run only once**

```{r message=FALSE}
GDCdownload(query = query_mut, directory = "GDCdata", method = "api")
```

Convert the downloaded files into a SummarizedExperiment object

```{r message=FALSE}
mut_data_prepared <- GDCprepare(query_mut)
```

Reading with maftools

```{r}
maf_obj <- read.maf(maf = mut_data_prepared)
```

Create the bianry matrix (Patients x Genes)

```{r}
mut_count_matrix <- mutCountMatrix(maf_obj) # matrix with the count of the mutations
```

Transpose the matrix in order to have patients on the rows and genes on the columns

```{r}
mut_matrix_binary <- t(mut_count_matrix)
```

Convert in binary (1 if mutated, 0 otherwise)

```{r}
mut_matrix_binary[mut_matrix_binary > 0] <- 1
```

Use only the 12-character patient ID as row names

```{r}
rownames(mut_matrix_binary) <- substr(rownames(mut_matrix_binary), 1, 12)
```

Remove possible duplicates

```{r}
mut_matrix_binary <- mut_matrix_binary[!duplicated(rownames(mut_matrix_binary)), ]
```

#### Patient Alignment (Expression vs Mutation)

We need to ensure both matrices analyze exactly the same set of patients.

```{r}
patients_rna <- substr(colnames(target_data), 1, 12) # patients used in the 5a section (expression)
patients_mut <- rownames(mut_matrix_binary) # patients available in mutations
```

Find the intersection (common patients)

```{r}
common_patients <- intersect(patients_rna, patients_mut)
```

Quick check

```{r}
cat("Esempio RNA:", head(patients_rna, 3), "\n")
cat("Esempio MUT:", head(patients_mut, 3), "\n\n")

cat("Patients with RNA data:", length(patients_rna), "\n")
cat("Patients with Mutation data:", length(patients_mut), "\n")
cat("Common patients for SNF:", length(common_patients), "\n")
```

**That means that each patient of which we have the genic expression, has also a mutation**

Matrix reorder (both matrices must have columns in the same order):

```{r}
# Expression Matrix (must be Patients x Genes but in 5a the dim was Genes x Patients
# and SNF needs the patients on the rows)
data_expression <- t(target_data[, common_patients])

# Mutation Matrix (Patients x Genes)
data_mutation <- mut_matrix_binary[common_patients, ]
```

Final check

```{r}
all(rownames(data_expression) == rownames(data_mutation)) # Must be TRUE
```

#### Calculation of Affinity Matrices

Standard parameters for SNF

```{r}
K <- 20      # number of neighbors
alpha <- 0.5 # hyperparameter for the construction of the affinity kernel
T_iter <- 20 # number of iteration needed for the fusion
```

First Layer: Expression

```{r}
dist_exp <- dist2(as.matrix(data_expression), as.matrix(data_expression)) # Euclidean distance 
W_exp <- affinityMatrix(dist_exp, K, alpha) # Affinity Matrix (W1)
```

Second Layer: Mutation

```{r}
dist_mut <- dist2(as.matrix(data_mutation), as.matrix(data_mutation)) # Euclidean distance
W_mut <- affinityMatrix(dist_mut, K, alpha) # Affinity Matrix (W2)
```

Fusion (Similarity Network Fusion)

```{r}
W_fused <- SNF(list(W_exp, W_mut), K, T_iter)
```

Assign the patient's names to the fused matrix

```{r}
rownames(W_fused) <- common_patients
colnames(W_fused) <- common_patients
```

#### Community Detection on the Fused Network

We apply Louvain clustering on the fused network to identify multi-omics communities.

Create the graph of the fused network:

```{r}
graph_snf <- graph_from_adjacency_matrix(W_fused, mode = "undirected", weighted = TRUE, diag = FALSE)
```

Apply Louvain

```{r}
louvain_snf <- cluster_louvain(graph_snf)
```

Create the dataframe of the SNF results

```{r}
comm_res_snf <- data.frame(
  patient = names(membership(louvain_snf)),
  community_snf = as.character(membership(louvain_snf)),
  stringsAsFactors = FALSE
)
```

Check

```{r}
cat("Number of communities found with SNF:", length(unique(comm_res_snf$community_snf)), "\n")
```

#### Plot of the Fused Network

Thresholding the matrix to improve readability

```{r}
l_comp_snf <- W_fused
threshold_snf <- 0.02
l_comp_snf[l_comp_snf < threshold_snf] <- 0
diag(l_comp_snf) <- 0
```

Network object

```{r}
net_snf <- network(l_comp_snf, matrix.type = "adjacency", ignore.eval = FALSE, names.eval = "weights", directed = FALSE)
```

Assign attributes

```{r}
net_names_snf <- network.vertex.names(net_snf)
net_snf %v% "community" <- comm_res_snf$community_snf[match(net_names_snf, comm_res_snf$patient)]

n_comm_snf <- length(unique(net_snf %v% "community"))
set.seed(123)
pal_snf <- sample(colors(distinct = TRUE), n_comm_snf)
names(pal_snf) <- sort(unique(net_snf %v% "community"))
```

Plot

```{r}
ggnet2(net_snf, 
       color = "community", 
       palette = pal_snf, 
       size = 6, 
       label = TRUE, 
       label.size = 3,
       edge.color = "gray90", 
       edge.alpha = 1) +
  ggtitle("SNF Community Structure (Expression + Mutation)")
```

#### Final comparison

Merge the results into a single dataframe

```{r}
comparison_df <- merge(comm_res, comm_res_snf, by = "patient")
colnames(comparison_df) <- c("Patient", "Cluster_RNA_Only", "Cluster_SNF")
```

Create a Confusion Matrix to show how patients move among groups when adding mutation data

```{r}
conf_matrix <- table(RNA_Only = comparison_df$Cluster_RNA_Only, 
                     SNF = comparison_df$Cluster_SNF)

print("Confusion Matrix (Rows: RNA Clusters, Cols: SNF Clusters):")
print(conf_matrix)
```

Transform the table in a dataframe for the plot

```{r}
melted_cmat <- as.data.frame(as.table(conf_matrix))
colnames(melted_cmat) <- c("RNA_Group", "SNF_Group", "Count")
```

Plot

```{r}
ggplot(melted_cmat, aes(x = SNF_Group, y = RNA_Group, fill = Count)) +
  geom_tile(color = "white") +
  geom_text(aes(label = Count), color = "black", size = 5) +
  scale_fill_gradient(low = "white", high = "tomato") +
  labs(title = "Comparison: RNA-Seq vs SNF Clusters",
       x = "SNF Communities (RNA + Mutation)",
       y = "RNA-Only Communities (5.1)") +
  theme_minimal() +
  theme(panel.grid.major = element_blank())
```

# PSN Communities Characterization (Clinical & Survival)

Stage 1 merges biological, clinical, and network-based information into a single patient-level table that will allow us to understand what defines each community and whether communities differ in survival or mutation patterns.

## 6. Clinical Data Integration

### Load libraries

```{r message=FALSE}
library(dplyr)
library(survival)
library(survminer)
library(maftools)
library(TCGAbiolinks)
library(stringr)
library(tidyr)


```

```{r}
length(unique(comm_res_snf$patient))
head(comm_res_snf)
```

```{r, results='hide'}
query_clin <- GDCquery(
  project = proj,
  data.category = "Clinical",
  data.type = "Clinical Supplement",
  data.format = "BCR XML"
)

# Only run once (then comment)
GDCdownload(query = query_clin)

clinical_kirp <- GDCprepare_clinic(query_clin, clinical.info = "patient")

```

```{r}
clinical_kirp <- clinical_kirp %>%
  mutate(
    patient = bcr_patient_barcode,
    survival_time = ifelse(!is.na(days_to_death),
                           days_to_death,
                           days_to_last_followup),
    survival_status = ifelse(vital_status == "Dead", 1, 0)
  ) %>%
  filter(!is.na(survival_time)) %>%
  select(patient, survival_time, survival_status, age_at_initial_pathologic_diagnosis, gender)
head(clinical_kirp)
```

```{r}
# Standardize patient column
comm_res$patient     <- substr(comm_res$patient, 1, 12)
comm_res_normal$patient <- substr(comm_res_normal$patient, 1, 12)
comm_res_snf$patient <- substr(comm_res_snf$patient, 1, 12)
clinical_kirp$patient <- substr(clinical_kirp$patient, 1, 12)

rownames(mut_matrix_binary) <- substr(rownames(mut_matrix_binary), 1, 12)
```

```{r}
str(mut_matrix_binary)  # patients × genes (0/1)
```

```{r}
DDR_genes  <- c("TP53", "ATM", "ATR", "BRCA1", "BRCA2", "CHEK1", "CHEK2")
TP53_path  <- c("TP53")
WNT_genes  <- c("APC", "CTNNB1", "AXIN1", "LRP5", "LRP6")
RTK_RAS_genes <- c("KRAS", "NRAS", "HRAS", "BRAF", "EGFR", "ERBB2")
PI3K_genes <- c("PIK3CA", "PTEN", "AKT1", "AKT2")

```

```{r}
DDR_genes      <- intersect(DDR_genes, colnames(mut_matrix_binary))
TP53_path      <- intersect(TP53_path, colnames(mut_matrix_binary))
WNT_genes      <- intersect(WNT_genes, colnames(mut_matrix_binary))
RTK_RAS_genes  <- intersect(RTK_RAS_genes, colnames(mut_matrix_binary))
PI3K_genes     <- intersect(PI3K_genes, colnames(mut_matrix_binary))
```

```{r}
pathway_matrix <- data.frame(
  patient = rownames(mut_matrix_binary),
  DDR      = as.integer(rowSums(mut_matrix_binary[, DDR_genes, drop = FALSE]) > 0),
  TP53     = as.integer(rowSums(mut_matrix_binary[, TP53_path, drop = FALSE]) > 0),
  WNT      = as.integer(rowSums(mut_matrix_binary[, WNT_genes, drop = FALSE]) > 0),
  RTK_RAS  = as.integer(rowSums(mut_matrix_binary[, RTK_RAS_genes, drop = FALSE]) > 0),
  PI3K     = as.integer(rowSums(mut_matrix_binary[, PI3K_genes, drop = FALSE]) > 0)
)

```

```{r}
tmb_res <- tmb(maf_obj)
tmb_df <- tmb_res %>%
  select(Tumor_Sample_Barcode, total_perMB) %>%
  mutate(
    patient = substr(Tumor_Sample_Barcode, 1, 12),
    TMB = total_perMB,
    TMB_high = TMB > 10
  ) %>%
  select(patient, TMB, TMB_high)

```

```{r}
clinical_kirp <- clinical_kirp %>%
  distinct(patient, .keep_all = TRUE)
clinical_kirp <- clinical_kirp %>% 
  filter(!is.na(survival_time), !is.na(survival_status))


```

```{r}
master_table <- comm_res_snf %>%
  rename(cluster_snf = community_snf) %>%
  
  # Add RNA-only PSN clusters
  left_join(comm_res %>% rename(cluster_rna = community),
            by = "patient") %>%
  
  # Add clinical survival data
  left_join(clinical_kirp,
            by = "patient") %>%
  
  # Add mutation pathway indicators
  left_join(pathway_matrix,
            by = "patient") %>%
  
  # Add TMB
  left_join(tmb_df,
            by = "patient")

```

```{r}
# Remove duplicates from master table
master_table <- master_table %>%
  distinct(patient, .keep_all = TRUE)
```

```{r}
cat("Number of patients in master table:", nrow(master_table), "\n")
head(master_table, 10)
summary(master_table)

```